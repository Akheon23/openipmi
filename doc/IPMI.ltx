\documentclass{book}
\usepackage{graphicx,moreverb,tabularx,acronym,longtable,alltt}
\title{IPMI -- A Gentle Introduction\\with OpenIPMI}
\author{Corey Minyard $<$minyard@acm.org$>$\\
        Montavista Software}
\date{\today}
%
\newcommand{\msgitem}[2]{#1&\parbox{0.8\textwidth}{\vspace{.15em}#2\vspace{.15em}} \\ \hline}
\newcommand{\msgtag}[1]{\multicolumn{2}{l}{#1}\\ \hline}
\newcommand{\msgcaption}[1]{\caption{#1}}
\newenvironment{showmsg}{\noindent\begin{longtable}{|p{.5in}|l|}}{\end{longtable}}
%\begin{showmsg}
%\msgtag{Request}
%\msgitem{}{}
%\msgtag{Response}
%\msgitem{}{}
%\msgcaption{\label{}, NetFN x (xxh), Cmd xxh}
%\end{showmsg}
%
\begin{document}
\maketitle

\frontmatter

\chapter{Preface}
This document describes \acs{IPMI} in great detail; how it works and
what it does and does not do.  It starts from the basics and moves
into details.  If you've heard about IPMI and want to find out more,
this is the document for you.  If you know something about IPMI but
wish to find out more, you can gloss over the introductory text and
dive more into the details.

\acs{IPMI} stands for Intelligent Platform Management Interface.  Not
a great name, but not too bad.  It is intelligent (in a manner of
speaking, anyway) because it requires a processor besides the main
processor that is always on and maintaining the system.  In most
systems with \acs{IPMI}, you can monitor and maintain the system even when
the main processor is turned off (though the system must generally be
plugged in).

Platform means that \acs{IPMI} deals with the platform, not the software
running on the platform.  Software management is mostly out of the
scope of \acs{IPMI}

Management Interface mains that the management system uses \acs{IPMI} to
talk to the system to monitor and perform manintenance on the
platform.  \acs{IPMI} is mostly about monitoring, though it does have a few
minor management functions.  However, many companies and organizations
have built more extensive management control using \acs{OEM} extensions to
\acs{IPMI}.

The specification for \acs{IPMI} is \cite{ipmi-spec}.

\tableofcontents

\chapter{Acronyms}
\begin{acronym}
\acro{IPMI}{Intelligent Platform Mangement Interface}
\acro{OEM}{Original Equipment Manufacturer}
\acro{SDR}{Sensor Device Record}
\acro{FRU}{Field Replacable Unit}
\acro{KCS}{Keyboard Style Controller}
\acro{BT}{Block Transfer}
\acro{SMIC}{Server Management Interface Chip}
\acro{MC}{Management Controller}
\acro{BMC}{Baseboard Management Controller}
\acro{I$^2$C}{Inter Integrated Circuit}
\acro{SNMP}{Simple Network Management Protocol}
\acro{HPI}{Hardware Platform Interface}
\acro{LUN}{Logical Unit Number}
\acro{NetFN}{Network FuNction}
\acro{IPMB}{Intelligent Platform Management Bus}
\acro{EEPROM}{Electronically Erasable Programmable Read Only Memory}
\acro{LAN}{Local Area Network}
\acro{SEL}{System Event Log}
\acro{PPP}{Point to Point Protocol}
\acro{RMCP}{Remote Management Control Protocol}
\acro{IP}{Internet Protocol}
\acro{UDP}{User Datagram Protocol}
\acro{MD2}{Message Digest 2}
\acro{MD5}{Message Digest 5}
\acro{PDU}{Protocol Data Unit}
  In SNMP, this is a packet holding an SNMP operation.
\acro{PEF}{Platform Event Filter}
\acro{MAC}{Media Access Code?}
\acro{ARP}{Address Resolution Protocol}
\acro{GUID}{Globally Unique IDentifier}
\acro{NMI}{Non Maskable Interrupt}
\end{acronym}

\chapter{Documents}

\mainmatter

\chapter{Management, Systems, and \acs{IPMI}}
Management will mean different things to different industries.  In
simple server systems, a management system may only deal with
controlling power on a few servers and making sure they don't get too
hot.  In a telecom system, management systems generally control every
aspect of the system, including startup of all parts of the system,
full monitoring of all components of the system, detection and
recovery from software and hardware errors, basic configuration of the
system, and a host of other things.  \acs{IPMI} obviously only plays one
role in this, but it is a role that must be played.  In the past, the
monitoring and management of hardware has been done with lots of
proprietary interfaces.  \acs{IPMI} standardizes this interface.

\begin{figure}
\includegraphics[width=\textwidth]{MgmtIF.eps}
\caption{\label{mgmtif}Management Interfaces}
\end{figure}

Figure \ref{mgmtif} shows a management system and the things it
manages.  \acs{IPMI} fits mostly within the ``Hardware'' box, although there
may be other hardware interfaces the management interfaces the
management system must manage.  The management system ties into all
elements of the system and makes global decisions based upon inputs
from all parts of the systems.  For instance, a server may be
overheating or have a low voltage.  The management system will be
informed of this through the hardware interfaces.  It may choose to
move the function of that server to another server and bring that
server down so it may be repaired.  If no other server is available to
take over the operation, the management system may look at the
severity of the problem, predict how long the system may survive, and
let it continue.  These types of decisions are called ``policy''.

In all cases these events are logged to permanent storage.  An
operator is informed of things that need human attention.  The
operater may also issue manual operations to configure and override
the management system as necessary.

The operations the management system performs on the system are called
``Commands'' in this picture.  Commands have ``Responses'' from the
system.  Asynchronous notifications from the system to the management
system are called ``Events''.  The system never sends commands to the
management system, and the system may perform local operations on its
own (such as controlling fan speed) but never perform global
operations unless pre-configured by the management system to do so.
So the system may perform limited policy decisions, but the management
system is firmly in control of policy.

\section{\acs{IPMI} Implementation}

The \ac{MC} sits at the center of an \acs{IPMI} system, providing the
``intelligence'' of \acs{IPMI}.  It is generally always on when the
system is plugged in, even if the system is off.  The management
system communicates with the management controller; the management
controller provides a normalized interface to all the sensors, events,
and \ac{FRU} data in the system.

\begin{figure}
\includegraphics[width=\textwidth]{ManagementController.eps}
\caption{\label{managementcontroller}Parts of a Management Controller}
\end{figure}

Figure \ref{managementcontroller} shows the various parts of the
management controller.  Note that most everything is optional;
depending on what a management controller does it may only need some
things.  The \ac{BMC} is required to have a lot of the items.

The \ac{MC} Processor is generally a small, inexpensive, but reliable
microcontroller.  Several companies sell processors that have a lot of
the \acs{IPMI} components already implemented and software to help a company
implement \acs{IPMI} on their system.

The system interface provides a way for the main processor to
communicate with the management controller.  Some systems do not have
this connection and only use external interfaces and/or \ac{IPMB}
interfaces.  System interfaces include \ac{SMIC}, \ac{KCS}, and
\ac{BT} interfaces.

An \ac{MC} (generally the \ac{BMC}) may have other interfaces to an external
management system through serial ports or Ethernet.

Generally, sensors sit on an \acs{I$^2$C} bus since many off-the-shelf
sensors can sit directly on the bus with no extra logic.  Wherever the
sensors sit, the \ac{MC} provides a more abstract interface to the sensors
so that the management system does not have to know the details of how
to talk to the sensor.  Sensors may be traditional analog sensors like
temperature and voltage.  But they may report other things, too, like
the current BIOS state, whether a device is present or not, or other
things like that.

\ac{FRU} data is often stored in \acs{I$^2$C} \acs{EEPROM}s on the
\acs{I$^2$C} bus.  \ac{FRU} data is information about a Field
Replacable Unit.  This includes things like the manufacturer, the
serial number, date of manufacture, etc.  A system generally has
information about the chassis and information about each field
replacable unit it has.  Field replacable units may include power
supplies, DIMMs (memory devices), plug-in-boards, or a host of other
things.

Connections to other \ac{MC}s may be done through an \ac{IPMB}.  On an
\ac{IPMB}, each MC is a peer and they communicate directly through
messages.

In addition to \ac{IPMB}, \acs{IPMI} systems can be interconnected through an
Intelligent Chassis Management Bus.  This is a serial bus that runs
between chassis.

A management controller may be able to control various aspects of the
chassis, such as power and reset.  It may also have a watchdog timer
for the main processor.

The \ac{SDR} repositories store information about the sensors and
components of the system.  The \ac{BMC} must have a main \ac{SDR}
repository; this repository is writable.  There may only be one main
\ac{SDR} repository in the system.  The device \ac{SDR} repository may
be on any \ac{MC} in the system; it is a read-only repository.

The event log holds asynchronous events in the system.  Events may be
forwarded through the system interface or other interfaces, but they
are always stored in the event log.  The \ac{BMC} must have an event log;
generally the other management controllers forward their events to the
\ac{BMC}.

\section{System Types}

Although any arbitrary type of system may use \acs{IPMI} for platform
management, systems generally fall into two categories: server systems
and bus systems.

\begin{figure}
\includegraphics[width=\textwidth]{ServerSystem.eps}
\caption{\label{typicalserver}A typical server system}
\end{figure}

Figure \ref{typicalserver} shows a typical server system.  It is a
single stand-alone box that is a single computer.  It has a \ac{BMC}
that is the main management controller in the system.  It controls a
number of sensors.  In this example, the power supply also has a
\ac{MC} with it's own sensors.

A \ac{BMC} can have several connections to managing systems.  It may have a
system interface connection to the main processor.  It may share an
interface to the ethernet chip so the system may be managed through
the \acs{LAN} when the main processor is not working.  System can have
serial port connections.  They can even have connections to modems
where they can dial up a management system when they detect a
problem, page an operator, or be dialed into by a management system.

\begin{figure}
\includegraphics[width=\textwidth]{BusSystem.eps}
\caption{\label{typicalbus}A typical bus system}
\end{figure}

Figure \ref{typicalbus} shows a typical bus system.  The word ``bus''
is perhaps a bit misleading; these types of systems used to have
busses (like CPCI and VME) but recently have tended to not have big
busses and use networking for interconnect (like PICMG 2.16 and ATCA).
These systems generally contain a number of processors on pluggable
boards often called Single Board Computers (SBCs) or blades.  One or
more power supplies power the whole system.  The boards and power
supplies can be hot-pluggable.

These systems generally have one or two boards that manage the system;
this can be on a standard SBC, on another special purpose blade (like
a blade used as a network switch), or on a standalone board with this
purpose.  The shelf management controller(s) generally act as the \ac{BMC}
in the system; they will have the event log and the \ac{SDR}s in the
system.  A system with two shelf controllers will generally allow the
system to be managed even if one of the shelf controllers fails.

Bus systems generally use one or more \ac{IPMB}s, a sister standard to
\acs{IPMI}) to interconnect the various components for management.
\ac{IPMB} is a modified \acs{I$^2$C} interface; it provides for a somewhat
slow but simple communication bus.

The boards can generally be individually power controlled, so even
though a board is plugged into the system it may be turned off.  The
shelf managment controller may implement some policy, such as fan
controls or auto-powering up boards, but is generally used as a
conduit for an external management system to control the parts of the
system.

Individal SBCs vary on whether the local Management Controller is
connected to the microprocessor on an SBC.  Some are, and some aren't.
This has some limited usefulness if the software on the SBC wishes to
obtain local information from the \acs{IPMI} system or store logs in the
\acs{IPMI} event log.

These types of systems are used to achieve high density in places with
expensive real-estate, like a telco central office.  As you might
imagine, you can pack a lot of processing power into a small space
with a system like this.  Since they are generally designed for
hot-swap, and can have I/O come out the back of the system on separate
cards, it makes mainenance easier.

%---------------------------------------------------------------------
\chapter{OpenIPMI}

So now we've got a \ac{BMC}, \ac{MC}s, and things like that.  But how are you
expected to use raw \acs{IPMI}?

The first things you must do, of course, it connect to the \ac{BMC}.  If it's
a direct SMI connection (A \ac{SMIC}, \ac{KCS}, or \ac{BT} interface, or perhaps a
non-standard serial interface), you just open the driver on the
operating system and start messaging.  If it's a \acs{LAN}-type connection,
you have to go through an authentication sequence.  One you have a
connection to the \ac{BMC}, things are pretty much the same no matter what
interface you have.  There are a few messaging for doing special
controls on a \acs{LAN} interface, but they don't generally matter to the
user.

Once the connection to the \ac{BMC} is up, the user should query to see what
channels the \ac{BMC} supports.  For 1.5 and later, it gets this from a
command.  For 1.0, it gets it from the main \ac{SDR} repository.

Once you are connected, you should scan the \ac{SDR}s in the main \ac{SDR}
repository for any entities and sensors.  Sensors and entities may
also be in the device \ac{SDR} repository, which should be scanned next.
This allows the user to discover the sensors in the system.  Note that
the sensors may point to entities that don't have a entry in the \ac{SDR}
that defines them, those entities need to be handled when they are
detected.

After this point in time, the interface could be deemed to be ``up''.
However, there's still more to do.

If the interface supports an event queue, the user will have to poll it
(if the driver doesn't deliver them asynchronously, that is).  If the
interface doesn't support an event queue the user should periodically
scan the system event log for new events.  (Note that even if it does
support an event queue, the user should still poll the system event log
in case the event queue missed any events coming in.)

Also, the user should start scanning the \ac{IPMB} bus with broadcast get
device id commands to detect any \ac{MC}s on the bus.

This is what the OpenIPMI library does for you.  Beyond this, it also
represents the sensors, controls, and entities in a nice OO fashion,
and it handles the details of addressing, message routing, and other
things you don't really care about.  It lets you get right at the
sensors and entities.

\section{The User View}

A bunch of acronyms have just been introduced, along with a lot of
vague concepts, and some description about how to use \acs{IPMI}.  The nice
thing is that the user of OpenIPMI doesn't really have to know about
all these things.

From the user's point of view, the entity provides the central
framework for everything sensors and controls.  Sensors monitor
entities.  Entities may be present or absent.  When you connect to an
interface, OpenIPMI takes care of detecting the entities in the system
and reporting them to you.  You may register to be told when entities
are added or removed from the database.  Note that an entity may be
present in the database, but not present in the system, the reporting
from only gives the presence in the database, not physical presence in
the system.

The user must know about two other OpenIPMI concepts: connections and
domains.  A connection provides the interface to the \acs{IPMI} system.  In
essence, it is the \ac{BMC} connection.  You must allocate one or more
connections and create a domain with them.  OpenIPMI supports multple
connections to a domain in some cases, but currently it requires the \acs{OEM}
plugins exist.  A domain represents a set of devices on a bus (like
\ac{IPMB}) whose entities will be unique.  For instance, a chassis with a lot
of cards plugged could be a domain, each card could be an entity and
then create it's own sub-entities, but they will be designed so the
entity id's don't collide.

OpenIPMI will automatically manage the connections, activating and
deactating the proper connections (if the connections support that),
detecting failures and switching over, etc.

Though the user doesn't have know the inner details of \acs{IPMI} addressing
and messaging, they do need to know about entities and sensors.
OpenIPMI mainly focuses on representing the entities and sensors in
convenient ways.  The user still needs to understand the capabilities of
sensors, how the sensors advertise those capabilties, and the things
that can be done to the sensors.

You may register with an entity to be told when it's physical presence
in the system changes.  Some devices (like power supplies) are
field-replacable while the system is running, these are called Field
Replacable Units (\ac{FRU}s).  They may have sensors that monitor them, but
those sensors may not be active if the device is not physically present
in the system.

Sensors and controls are also automatically detected and reported.
This is done through entities, you register with an entity to be told
when a sensor or control has been added or removed.

\section{OpenIPMI Concepts}

OpenIPMI is an event-driven library that is designed to be relatively
operating system independent.  If you have written control systems or
things like that in the past, you will be quite familiar with
event-driven systems and may skip to the next section.  If not, you want
to read this.  Event-driven systems may seem a little unusual, but they
are accepted practice and by far the best way to build control systems.

\subsection{Event-Driven Systems}

In an event-driven system, you never stop and wait for something to
happen.  If you are not used to this, you are probably used to writing
code like this:

\begin{verbatim}
  while (true) {
    wait_for_input();
    perform_op1();
    wait_for_op1_results();
    perform_op2();
  }
\end{verbatim}

This is fairly straightforward, but it has some problems.  What if
another more important input comes in while you are waiting for the
results of \verb=perform_op1()=?  Now the program will have to handle
input in \verb=wait_for_op1_results()=, too, and somehow return and
say something is happening.  The loop will then have to somehow handle
multiple operations in progress.  And this is a simple example, what
if there were hundreds of possible inputs, each with their own result
handler, and each had to go through several states?  You could assign
each to a thread, but if you have thousands of possible pending
operations in a system, that many threads may thrash your system and
render it inoperable, probably right at the time you need it most
(since a lot of things are going on).

In an event-driven system, instead you would say:
\begin{verbatim}
  init()
  {
    <initialize input_data>
    register_for_input(op1_handler, input_data);
  }
  op1_handler(input_data)
  {
    <allocate and initialize op_data>
    perform_op1(..., op2_handler, op_data);
  }
  op2_handler(op_data)
  {
    perform_op2();
    <free op_data>
  }
\end{verbatim}

As you see, when you start an operation, you provide the next thing to
call when the operation completes.  The functions passed around are
called ``callbacks''.  You allocate and pass around chunks
of data to be passed to the handlers.  And you register input handler
that get called when certain event occur.  So the code runs in short
non-blocking sections, registers for the next operation, then returns
back to some invisible main loop that handles the details of scheduling
operations.  This may seem more complicated than the previous example,
but it has a large number of advantages:
\begin{itemize}
\item The system is almost always ready to handle input.  For instance,
user-interface systems (like most widget sets) are almost always
event-driven, this
makes them much more ``live'', since they are always ready to handle
user input.
\item This system can handle multiple simultaneous operations without
threads.  In general, threaded systems are less reliable and more
complicated, unless you need priorities or scalability on SMP, why use
them?  And even if you use them, you can have much better control over
what is running in the system.
\item If you are building a redundant system with data replication, this
gives you a natural way to hold your data, know when to transfer it over
to the mate system, and continue an operation on the mate system.
\item If you track the data, it's easy to monitor every operation
occuring in the system, stop an operations, or whatever.
\item It's much easier to detect and manage overload situations in an
event driven system.  Event-driven systems have event queues of things
waiting to be processed.  You can put things in the queue and watch the
queue length.  If the queue length gets too big, you are in overload,
and can intelligently decide which events you want to throw away, based
on priority, time to live, or some other criteria.
\end{itemize}

In general, a threaded system is easier to conceptually understand until
you understand event-driven methods.  An event-driven system is almost
always easier to correctly implement.

Note that event-driven systems don't preclude the use of threads.
Threads may be vastly overused, but they are important.  You could, for
example, allocate one event loop thead per CPU to help scale your
system.  You need to use threads to manage priorities.  Some inputs may
be more important than others, so you may have an event loop for each
priority and feed them that way.  You have a thread per CPU, and/or a
thread per priority, but you don't need a thread per operation.

This is often called ``state-machine programming'' since most control
systems are state-machine based, and this is a natural way to implement
a state machine.  The \verb=op_data= holds the state of the state
machine, each input gets \verb=op_data=, looks at the current state, and
decides what to do next.

The OpenIPMI library is completely event-driven.  It has no internal
blocking operations, and it expects that anything it calls will not
block.  \acs{IPMI} messaging and operating system primitives are provided
through external plug-in pieces.

If a library function that takes a callback does not return an error,
the callback is guaranteed to be called, even if the object the call is
associated with goes away.  If it goes away, a NULL may be passed in as
the object to the callback, but the \verb=cb_data= will still be valid.

\subsection{The OS Handler}
\label{openipmi-os-handlers}

The OS handler provides services for the OpenIPMI library.  OpenIPMI
needs some things from the operating system that are not standardized
by the C language.  The os-handler include file is shown in Appendix
\ref{os-handler-h}.

\subsubsection{OS Handler Services}

The classes of services required by OpenIPMI are:

\begin{description}
\item[Input Callbacks]
The OpenIPMI code uses the ``file descriptor'' concept of *nix, input
devices are numbered.  This is not used internally in the library, but
it is used by the messaging interfaces, so the messaging interfaces and
OS handler may implement their own conventions for these numbers.  This
provides a way for OpenIPMI to register to receive input from devices.

\item[Timers]
OpenIPMI times everthing (as it should), thus it needs timers.

\item[Locks]
OpenIPMI does not require locks, you may leave the operations NULL and
they won't be used.  However, if you are doing multi-threaded
operations, you should provide locks.  The locks should be recursive
(the same lock may be claimed multiple times by the same thread).  You
need to provide read/write locks operations, although these may be
normal locks (the system will just be less responsive).

\item[Condition Variables]
These are condition variables like the ones specified in POSIX threads.
Although OpenIPMI does not use condition variables (since it never waits
for anything) it may be convenient for other things to have them.
OpenIPMI does not use them, and if nothing in your system needs them,
they need not be provided.

\item[Random Data]
For certain operations, OpenIPMI needs random data.

\item[User Functions]
Not used by OpenIPMI, but available for the user for special things the
user will need.
\end{description}

\subsubsection{Standard User Functions in the OS Handler}
\label{std-func-os-handler}

OS handlers have some standard functions pointers for the user.  These
are:

\begin{tabularx}{\textwidth}{lX}
\verb=free_os_handler= &
Free the OS handler.  Do not use the OS handler after calling this.\\

\verb=perform_one_op= &
Handle one event (a timer timeout or a file operation) and return.
This takes a timeout; it will wait up to the amount of time given for
the event.\\

\verb=operation_loop= &
Continuously handle events.  This function will not return.\\
\end{tabularx}

These operations may not be available on all OS handlers, see the
particular OS handler you are using for more details.

These are part of the OS handler.  As an example on how to use them,
the following code performs one operation, prints any error it
returns, then frees the OS handler:

\begin{verbatim}
struct timeval tv;
int            rv;
tv.tv_sec = 10;
tv.tv_usec = 0;
rv = os_hnd->perform_one_op(os_hnd, &tv);
if (rv)
  printf("Error handling operation: 0x%x", rv);
os_hnd->free_os_handler(os_hnd);
\end{verbatim}

\subsubsection{POSIX OS Handlers}

OS handlers are already defined for POSIX systems, both with and
without threads.  These are defined in the include file
\verb=ipmi_posix.h=; see that file for more details.  The main
functions you need to know are the allocation, mainloop, and
deallocation code.  If you are running in a threaded application, you
almost certainly should use the threaded version of the OS handlers.

To allocate a POSIX OS handler, use one of the following:

\begin{verbatim}
os_hnd = ipmi_posix_setup_os_handler();

os_hnd = ipmi_posix_thread_setup_os_handler(wake_sig);
\end{verbatim}

The \verb=wake_sig= is a signal number that your program is not using
(usually \verb=SIGUSR1=, \verb=SIGUSR2=, or a real-time signal).  The
OS handlers uses this signal to send between threads to wake them up
if they need to be woken.

Freeing and handling the OS handler is done with the standard
functions in the OS handler, described in section
\ref{std-func-os-handler}.

\subsection{Error Handling}

Almost all OpenIPMI calls that do anything besides fetch a piece of
local data will return an integer error value.  A zero means no error.
Two types of errors are returned, system errors (which are standard
Unix errno values) and \acs{IPMI} errors (which are the standard
\acs{IPMI} error codes).  You can use the macros \verb=IPMI_IS_OS_ERR=
and \verb=IPMI_IS_IPMI_ERR= to tell the type of error, and
\verb=IPMI_GET_OS_ERR= and \verb=IPMI_GET_IPMI_ERR= to get the actual
error values.

Note that if your system doesn't have Unix-type error numbers, you will
have to provide those for the OpenIPMI library.

If a function returns an error, any callbacks provided to that
function will \emph{never} be called.  If a function that takes a
callback returns success, the callback will \emph{always} be called,
even if the object associated has ceased to exist.  If an object with
outstandard operations ceases to exist, all the callbacks for
outstanding operations will be called with \verb=ECANCELED= as the
error.  Errors are passed into many callbacks, if an error is present
the rest of the data in the callback is probably not valid except for
the \verb=cb_data= variable you provide, and possibly the object the
callback is associated with.  The object the callback is associated
with may be NULL if it has ceased to exist.

\subsection{Locking}

As mentioned before, you may or may not be using locking, \emph{but
you must read this section anyway.}  Locking here involves existance of
entities as well as normal locking.

Locking has changed between OpenIPMI 1.3 and 1.4.  In OpenIPMI 1.3,
locks were held in user callbacks.  Locking was very course grained
and the locks were recursive, so this was generally not a problem.
However, in general it is a bad idea to hold locks in user callbacks.
The user might have two domains and do things between them, resulting
in possible deadlocks.  Because of this, locking strategy has changed
in OpenIPMI 1.4.  The interfaces and basic usage are completely
unchanged, but the semantics have changed.

\subsubsection{Locking principles}

The basic principle of locking is that if you are in a callback for an
\acs{IPMI} object (an \acs{IPMI} object is passed in the callback), that object is
refcounted (marked in-use) and the system cannot delete it.  In any
callback for an object owned by a particular domain, that object will
be and anything it belongs to will be marked in-use.  So, for
instance, in a callback for a sensor, the sensor is in-use, the entity
the sensor belongs to is in-use, the management controller the sensor
is on is in-use, and the domain the sensor is in will be in-use.  No
other sensors, entities, or management controllers will necessarily be
marked in-use.  Outside of callbacks, the library is free to change
pointers, change information, add and remove objects, or whatever it
wants to objects.

So how do you mark an \acs{IPMI} object in-use?  If you are handling
incoming \acs{IPMI} callbacks you generally don't have to worry about this.
But say you are handling outside input, such as a user interface.
What then?  If the pointers can change, how do I keep a reference to
something?

OpenIPMI provides two identifiers for \acs{IPMI} objects.  One is a pointer,
but a pointer is only good inside a callback.  The other is an
OpenIPMI id, the id is good outside callbacks.  But the only thing you
can do with an id is pass it to a function that will call a callback
for you with the pointer.  You can convert a pointer to an id (inside
a callback, of course) so you should do that if you need to save a
reference to the object.  Note that there are some functions that take
ids that do this for you (such as \verb=ipmi_sensor_id_reading_get()=,
other sensor functions, hot-swap functions, and a few others); these
are provided for your convenience.

This mechanism, though a little inconvenient, almost guarantees that
you will not forget to decrement a use count.  It nicely encapsulates
the locked operation in a function\footnote{This is how locking works
in Ada95 and Java, although their mechanisms are a little more
convenient since they are built into the language}.  You have to
return from the function unless you exit, longjmp, or throw an
exception that falls through the callback, and you shouldn't do those
things.

You \emph{must} do this whether you are using locking or not, because the
library uses this mechanism to determine whether the id you are holding
is good.  Once it converts the id to the pointer, your pointer is
guaranteed to be good until the function returns.

These functions are named \verb=ipmi_xxx_pointer_cb()=, where ``xxx''
is control, entity, domain, or sensor.  Unlike many other callbacks,
the callback function you provide to these functions will be called
immediately in the same thread of execution, this callback is not
delayed or spawned off to another thread.  So, for instance, you can
use data on the stack of the calling function and pass it to the
callback function to use.

\subsubsection{Locking example}

For instance, suppose you have a callback registered with the domain
for finding when new entities are ready, and you are looking for a
specific entity.  The code might look like:

\begin{verbatim}
ipmi_entity_id_t my_entity_id = IPMI_ENTITY_ID_INVALID;

static void
entity_change(enum ipmi_update_e op,
              ipmi_domain_t      *domain,
              ipmi_entity_t      *entity,
              void               *cb_data)
{
    ipmi_entity_id tmp_id;

    switch (op) {
        case IPMI_ADDED:
            if (entity_i_care_about(entity))
                my_entity_id = ipmi_entity_convert_to_id(entity);
            break;

        case IPMI_DELETED:
            tmp_id = ipmi_entity_convert_to_id(entity);
            if (ipmi_cmp_entity_id(my_entity_id, tmp_id) == 0)
                ipmi_entity_id_set_invalid(&my_entity_id);
            break;

        default:
            break;
    }
}
\end{verbatim}

In this example, the entity is in-use in this call, because you have
received a pointer to the entity in the callback.

However, suppose you want to use the entity id later because the user
asks about the entity to see if it is present.  You might have a piece
of code that looks like:

\begin{verbatim}
static void
my_entity_id_cb(ipmi_entity_t *entity, void *cb_data)
{
    my_data_t *data;

    data->exists = 1;
    data->present = ipmi_entity_is_present(entity);
}

void
check_if_my_entity_present(my_data_t *data)
{
    int rv;

    data->exists = 0;
    data->present = 0;
    rv = ipmi_entity_pointer_cb(my_entity_id, my_entity_id_cb, data);
    if (rv)
        printf("The entity could not be found\n");
}
\end{verbatim}

Most of the data about the various OpenIPMI objects is static, so you
can pre-collect the information about the objects in the callback
where there existance is reported.  The only dynamic variable in
OpenIPMI is entity presence.  Also, many operation require a message
to the remote system; the ones that take callbacks.  For these
operation, functions that directly take the id are available.

The entity presence code could be rewritten using this to be:

\begin{verbatim}
void
check_if_my_entity_present(my_data_t *data)
{
    int rv;

    data->exists = 0;
    data->present = 0;
    rv = ipmi_entity_id_is_present(my_entity_id, &data->present);
    if (rv)
        printf("The entity could not be found\n");
    else
        data->exists = 1;
}
\end{verbatim}

So, it is recommended that you collect all the static information that
you need from an object when it is reported to you.

\subsubsection{Locking semantics}

As mentioned before, OpenIPMI will not delete an object you have a
pointer to while in a callback, but in multi-threaded systems it is
free to do pretty much anything else to the object, including call
callbacks on it.  This means, for instance, that you can be iterating
over the entities in the system and a new entity can be added, have
the entity update callback called on it, and be added to the list.
There is no guarantee or order between the adding of entities to the
list and the callback.  So the new entity might be iterated, it might
not, the iteration might be before or after the the callback, etc.

How can you avoid this?  You have a few options:

\begin{itemize}
\item Ignore the problem.  I strongly recommend that you do not take this
option.

\item Single-thread your program.  If you don't need be able to take
advantage of multiple CPUs in an SMP system, and you have no need for
priorities, single-threading is a good option.  With OpenIPMI, you can
have a single-threaded application that is non-blocking and can
perform very well.  Plus, single-threaded programs are easier to
debug, easier to understand and maintain, and more reliable.

\item Do your own locking.  OpenIPMI used to hold locks for the user while
in callbacks.  This is, in general, a bad idea.  OpenIPMI does not
know what the user is doing.  This can result in deadlocks if the user
is not careful, and it make it hard for the user to handle multiple
things\footnote{For instance, if you have two callbacks on two
sensors, and each of them then did a locking operation on the other
sensor, you can end up in a deadlock situation where one thread holds
one lock, another thread holds another lock, and they are both waiting
for the lock the other is holding}.  Instead, the user must do their
own locking.  For instance, you could claim a lock in both the entity
iteration and the callback for a new entity.  This would prevent the
both pieces of code from running at the same time.  You are in control
of the locks, so you can handle it as appropriate.  You have to know
what you are doing, but that goes without saying when doing
multi-threaded programming.
\end{itemize}

Note that this may seen abnormal, but it is pretty standard in
multi-threaded systems.  \ac{HPI}, for instance has the same problem.
If you have one thread waiting for events from an \ac{HPI} domain, and
another iterating the RDRs, or you have two threads each doing
operations on sensors, you have exactly the same situation.  You have
to protect yourself with locks the same way.

Note that data about an object (like the device id data, whether the
\ac{MC} is active, or the entity is present, or whatever) will \emph{not}
change while the object is in use.  This data is held until the object
is no longer in use and then installed (and in the case of activity or
presence, the callbacks are then called).

\subsection{OpenIPMI Objects}

In OpenIPMI, the user deals with six basic objects: connections,
domains, entities, sensors, controls, and events.

\subsubsection{Connections}

A connection provides the low-level interface to the system.  It is
usually a connection to a \ac{BMC} in a system.  It handles getting \acs{IPMI}
messages to the proper elements in the system.

\subsubsection{Domains}

The domain is the container for the system, the entities in the system
are attached to the it.  You create a domain with a connection to a
system; the domain handles the job of discovery of the things in the
system.

\subsubsection{Entities}

Entities are things that are monitored.  They may be physical things
such as a power supply or processor, or more abstract things such as the
set of all power supplies or the ambient air in a chassis.  Sensors
monitor entities, and controls are attached to entities.

Entities may be grouped inside other entities, thus an entity may have a
parent (if it is grouped inside another entity) and children (if it
contains other entities).  These relationships are abstract; you may
change them if it you like.  A raw system with no \ac{SDR} data will not have
any relationships defined.  Relationships are stored in the \ac{SDR}
repository, you may change them and store them back, if you like and if
the system supports that.

\ac{FRU} information about the entity is sometimes available.  You can
register with an entity to see if/when it becomes available using
\verb=ipmi_entity_add_fru_update_handler()=.  Once it is available,
you can fetch the \ac{FRU} data using the commands defined in the \acs{IPMI}
include file.

\paragraph{Device-Relative vs System-Relative Entities}

In \acs{IPMI}, entities may be be either in a fixed place in the system, or
they may be moved about the system.  Fixed entities, are, well, in a
fixed location in the system.  These are called system relative
entities.  They have an entity instance less than 60h.

Other entities may not reside in a fixed location.  For instance, a
power supply or CompactPCI board may be plugged in to one of many
locations in a chassis; it doesn't know ahead of time which one.
These types of entities are generally device-relative and have an
entity instance of 60h or larger.  For these types of entities, the
management controller on which they reside becomes part of the entity.
In OpenIPMI, the \ac{IPMB} channel number of \ac{IPMB} address are part of the
entity.  In \verb=ipmi_ui=, these are printed and entered as
``r<channel>.<ipmb>.<entity id>.<entity instance>''.

\subsubsection{Sensors}

Sensor monitor something about an object.  \acs{IPMI} defines many types of
sensors, but groups them into two main categories: Threshold and
discrete.  Threshold sensors are ``analog'', they have continuous (or
mostly continuous) readings.  Things like fans speed, voltage, or
temperature.

Discrete sensors have a set of binary readings that may each be
independently zero or one.  In some sensors, these may be independent.
For instance, a power supply may have both an external power failure and
a predictive failure at the same time.  In other cases they may be
mutually exclusive, such as the initialization state of a piece of
software.

\subsubsection{Controls}

Controls are not part of the \acs{IPMI} spec, but are necessary items in
almost all systems.  They are provided as part of OpenIPMI so that \acs{OEM}
code has a consistent way to represent these, and so OpenIPMI is ready
when the \acs{IPMI} team finally sees the light and adds controls.  OpenIPMI
defines many types of control: lights, relays, displays, alarms,
reset, one-shot-reset, power, fan speed, general outputs, one-shot
outputs, and identifiers.

For all controls except displays and identifiers, the control may
actually control more than one device.  With some controls, multiple
device may be controlled together and individual ones cannot be set (ie,
the same message sets all of them).  For these types of controls,
OpenIPMI represents them as a single control with multiple devices.
All the devices are read and set at once.

Reset controls are reset settings that can be turned on and off.
One-shot-reset controls cause a reset by setting the value to 1; they
are not readable and setting to zero returns an error.

Lights are on/off colored devices, like an LED.  They may be
multi-color, but can only show one color at a time.  For instance, if
you work for Kmart, or you are managing a CompactPCI system with
hot-swap, you will have a blue light in your system.  You can search
through the controls to find a light that's blue.  Then, if a special
is on, or you want the operator to remove a card, you can light the blue
light.  Lights may blink, too.  Each light can have settings.  Each
setting describes a sequence of one or more transitions the light may go
through.

Relays are binary outputs.  Most telephony systems have them; they are
required by telephony specs.  They are simple on/off devices.

Displays are two-dimensional arrays of characters.  OpenIPMI allows you
to change individual characters at will.

Alarms are bells, whistles, gongs, or anything to alert the user that
something is wrong.

Reset controls are used to reset the entity to which they are attached.

Power controls can be used to control power to or from an entity.  A
power control on a power supply would generally control output power.  A
power control on a board would generally control input power to the
board.

Fan speed controls can be used to set the speed of a fan.

General outputs are outputs that don't fall into one of the previous
categories.  One-shot outputs are like general outputs, but perform
some action when set to one and are not readable.  Setting them to
zero returns an error.

Identifier controls hold identification information for a system, such
as a chassis id, chassis type, geographic address, or whatever.

\subsubsection{Events}

When an external event comes into OpenIPMI, the user will always
receive that event in some manner (unless they do not register with a
generic event handler, but they should always do that).  The event may
come through a callback for a sensor, control, entity, or other
callback.

All the callbacks you should be using return a value telling whether
the handler has ``handled'' the event.  Handling the event means that
the callback is going to manage the event.  Primarily, this means that
it is responsible for deleting the event from the event log with
\verb=ipmi_event_delete()=.  If no callback handles the event, then it
will be delivered to the main event handler(s).  This allows calls to
receive events but the events to be managed in a single location.

If a callback handles the event, then all future callbacks called due
to the event will receive a \verb=NULL= for the event.  So be ready to
handle a \verb=NULL= event in all your event handlers.  A \verb=NULL=
may also be passed to an event handler if the callback was not due to
an event.

\subsection{Callbacks}

As you will discover, OpenIPMI is very callback based.  The callbacks
are somewhat fined grained; you register for exactly what you want to
see on individual objects.  This is not as bad as you might imagine
(even though it may seem somewhat strange).  It does mean that you
have to do a lot of registering in all the right places, though.  \acs{IPMI}
has a large number of asyncronous things that it has to inform you
about.  If it delivered all these through one interface, you would
have to look at each call and try to figure out what type of things
was being reported, what object is was associated, etc.  In effect,
that work is done by OpenIPMI.

\subsubsection{Updated Callbacks}

Updated callbacks tell you when an object comes into existance, is
destroyed, or if configuration information about an object has
changed.  On an entity, for instance, when an entity is first added,
the entity update handler on the domain will be called with the
entity.  when an \ac{SDR} is read and causes a change to the entity, the
updated handler will be called again with the change.  When the entity
is deleted, it will be called again.

In general, you should add updated handlers whenever the thing you
want to register against comes into existance.  So for entities and
the main event handler, you should register them in the
\verb=setup_done= callback for the domain.  The entity update handler
should register the update handlers for sensors, controls, and \ac{FRU}
information.  It should register the event handlers for presence and
hot-swap there, too.

Sensor and control update handlers should set up and register for
events from the sensor.

\subsubsection{Event Based Callbacks}

Event based callbacks tell you when asynchronous things happen in the
system.  For instance, a card gets plugged in and an entity becomes
present.  You will be told with the present callback on the entity.
The hot-swap state of an entity changes.  That is reported via the
hot-swap state callback.  Events because of sensors going out of range
is another example.

Note that the handlers don't get called with current state when you
add an event-based callback handler.

\subsubsection{Synchronous Callbacks}

Synchronous callbacks are callbacks for things you request and are
one-shot operations.  For instance, if you want to know the current
value of a sensor, you call call \verb=ipmi_reading_get()= and you
give it a handler to call when the reading has been fetched.

This is always done for things that OpenIPMI might have to send a
message to do.  If it a result of OpenIPMI's requirement to be able to
work in non-threaded systems and still be responsive to operations
while waiting.

\section{OpenIPMI Include Files}

OpenIPMI has a large number of include files.  Most of them deal with
internals that are only needed for \acs{OEM} code.  The include file
are classified by need in the sections below.

\subsection{Files the normal user deals with}

\begin{tabularx}{\textwidth}{lX}
\verb=ipmiif.h= & 
The main include file for OpenIPMI.  It contains the main functions the
user must deal with when working with the OpenIPMI library.  Almost
everything will include this.  It includes \verb=ipmi_types.h= and
\verb=ipmi_bits.h=, too, so you don't have to include those.\\

\verb=ipmi_auth.h= &
The file holding information about athentication algorithms.  You need
this if dealing with an authenticated interface.\\

\verb=ipmi_bits.h= &
Various values, mostly for sensors, used by the user.  \verb=ipmiif.h=
includes this file, so you generally don't have to include it explicitly.\\

\verb=ipmi_types.h= &
Types for the basic IPMI objects.  \verb=ipmiif.h= includes this file,
so you generally don't have to include it explicitly.\\

\verb=ipmi_err.h= &
Error values, both IPMI and system, as well as macros for interpreting
these.\\

\verb=os_handler.h= &
The os-specific handler types are defined here.  You must implement this
and supply it to the IPMI code.\\

\verb=selector.h= &
For *nix systems, This file a default mechanism for handling many of the
os-specific handler operations.\\

\verb=ipmi_log.h= &
Holds definitions for the logging interface.\\

\end{tabularx}

\subsection{Files dealing with messaging interfaces}

\begin{tabularx}{\textwidth}{lX}
\verb=ipmi_lan.h= &
This is the \acs{LAN} messaging interface, this contains the calls for
creating a \acs{LAN} connection.\\

\verb=ipmi_smi.h= &
This is the messaging interface for talking to local IPMI interfaces
(like KCS), this contains the calls for creating an SMI connection.\\

\end{tabularx}

\subsection{File for system configuration}

\begin{tabularx}{\textwidth}{lX}
\verb=ipmi_pef.h= &
Contains code for configuring the \ac{PEF}.\\

\verb=ipmi_lanparm.h= &
Contains code for configuring the \acs{LAN} configuration data.\\

\verb=ipmi_pet.h= &
Contains code that allows the user to easily set up an IPMI \acs{LAN}
interface on a BMC to send traps.\\

\end{tabularx}

\subsection{Internal files that OEM code and messaging interfaces deal with}

\begin{tabularx}{\textwidth}{lX}
\verb=ipmi_addr.h= &
The file holding information about IPMI addresses.\\

\verb=ipmi_conn.h= &
This defines the interface for the messaging interfaces.\\

\verb=ipmi_event.h= &
This defines functions for handling events.\\

\verb=ipmi_entity.h= &
This defines internal entity interfaces.\\

\verb=ipmi_fru.h= &
This defines internal FRU interfaces.\\

\verb=ipmi_control.h= &
This defines internal control interfaces.\\

\verb=ipmi_int.h= &
This defines other miscellaneous internal interfaces.\\

\verb=ipmi_domain.h= &
This defines the internal interfaces for dealing with domains.\\

\verb=ipmi_mc.h= &
This defines internal interfaces for the management controllers.\\

\verb=ipmi_msgbits.h= &
This defines various IPMI messages.\\

\verb=ipmi_oem.h= &
This defines interfaces that OEM code can tie into.\\

\verb=ipmi_sel.h= &
This defines the internal interfaces for the \ac{SEL}.\\

\verb=ipmi_sdr.h= &
This defines internal interfaces for the \ac{SDR} repostiory.\\

\verb=ipmi_sensor.h= &
This defines internal interfaces for sensors.\\

\verb=ipmi_locks.h= &
This defines internal interfaces for locks.\\

\verb=ipmi_posix.h= &
This defines some POSIX OS handlers.\\

\end{tabularx}

\section{Starting Up OpenIPMI}
\label{starting-up-openipmi}

Starting up OpenIPMI is relatively easy.  You must allocate an OS
handler and initialize the library with it.  Then you are free to set
up connections.  The following code shows this for a non-threaded
POSIX program:

\begin{verbatim}
    os_hnd = ipmi_posix_setup_os_handler();
    if (!os_hnd) {
	printf("ipmi_smi_setup_con: Unable to allocate os handler\n");
	exit(1);
    }

    /* Initialize the OpenIPMI library. */
    ipmi_init(os_hnd);
\end{verbatim}

The \verb=ipmi_init= function should be done \emph{once} when your
program starts up.  Generally, you only have one OS handler, but you
are free to have more if they interwork properly and you have some
special need.

\section{Creating OpenIPMI Domains}
\label{creating-openipmi-domains}

If you want to talk to an \acs{IPMI} \ac{BMC}, you must create a
connection to it.  The connection method depends on the type of
connection; these are described in Chapter \ref{ipmi-interfaces}.

Once you have a connection, you can open a domain with it.  You do
this like so:

\begin{verbatim}
ipmi_con_t       cons[N];
int              num_cons, rv;
ipmi_domain_id_t id;

/* Set up connection(s) here */

rv = ipmi_open_domain(cons, num_cons, con_change, user_data, &id);
\end{verbatim}

Up to two connections are currently supported.  A connection is an
independent \ac{MC} in the same domain; if two MCs have external
connections, they can both be used for fault-tolerance.  This
generally requires some special support for the particular domain
type, see the appendices ons pecific domain types for more detail.
The \verb=con_change= function is called whenever the connection
changes states (a connection is established or lost).  The connection
change callback looks like:

\begin{verbatim}
static void
con_change(ipmi_domain_t *domain,
	   int           err,
	   unsigned int  conn_num,
	   unsigned int  port_num,
	   int           still_connected,
	   void          *user_data)
{
  ...
}
\end{verbatim}

If a connection is established, then \verb=err= will be zero.
Otherwise it is the error that caused the connection to fail.  The
\verb=conn_num= parm is the particular connection number (from the
\verb=cons= array passed into the domain setup).  A connection may
have specific ports, generally multiple connections to the same
\ac{MC}.  The \verb=still_connected= parm tells if you still have some
connection to the domain.

If a connection is down, the connection change callback will be called
periodically to report the problem as OpenIPMI attempts to
re-establish the connection.

%---------------------------------------------------------------------
\chapter{IPMI Interfaces}
\label{ipmi-interfaces}

\acs{IPMI} has a large number of interfaces for talking to to management
controllers.  They vary in performance and capability, but the same
messages work over the top of all of them.  Generally, it does not
matter how you interface to an \acs{IPMI} system, the messages will work the
same.

\section{OpenIPMI Generic Interface}
\label{openipmi-generic-interface}

The OpenIPMI libary has a generic interface to the various
connections.  You use a per-interface command to set up the interface,
but once set up, the interfaces all work the same.  The file shown in
Appendix \ref{ipmi-conn-h} defines the interface for connections.

Note that not all operations are not available on all interfaces.  \acs{LAN}
connections, for instance, cannot receive commands.

\section{System Interfaces}

The most common interface to a management controller is the system
interface.  This provides a direct connection between the main
processor of a system and the management controller.  Obviously, this
interface isn't very useful if the system is turned off, but it allows
a running system to monitor itself.

The low-level format of a system interface message that is $n$ bytes
long is:

\begin{showmsg}
\hline
\msgitem{0}{Bits 0-1 - Destination \acs{LUN}\\
	    Bits 2-7 - \acs{NetFN}}
\msgitem{1}{Command}
\msgitem{2 - n-1}{Message Data}
\end{showmsg}

Commands and responses have basically the same format, except that
responses always have the completion code as the first byte of the
message data.  See chapter \ref{ipmi-commands} for more details.

\subsection{\ac{SMIC}}
The \ac{SMIC} interface has been around a long time, but mostly during
a period when \acs{IPMI} was not popular.  This is a low-performance,
byte-at-a-time interface with no interrupt capability.

\subsection{\ac{KCS}}
The \ac{KCS} interface is currently the most popular \acs{IPMI} system
interface.  The \ac{KCS} interface looks much like a standard PC
keyboard interface.  It was chosen because lots of cheap hardware was
available for these types of interfaces.  But it is still a
byte-at-a-time interface and performs poorly.  It has the capability
for interrupts, but very few systems have working interrupt capability
with \ac{KCS} interfaces.

\subsection{\ac{BT}}
The \ac{BT} interface is the newest and best interface for \acs{IPMI}.
Messages are sent a whole message at a time through the interface,
thus it is a much higher performance interface than the other system
interfaces.

\subsection{The OpenIPMI Driver}

The OpenIPMI driver on Linux provides a user interface to all the
standard \acs{IPMI} system interfaces.  It does so in a manner that allows
multiple users to use the driver at the same time, both users in the
kernel and users in user space.

To do this, the OpenIPMI driver handles all the details of addressing
and sequencing messages.  Other drivers allowed more direct access to
the \acs{IPMI} interface; that means that only one user at a time could use
the driver.  Since the \acs{IPMI} can be used for different purposes by
different users, it is useful to do the multiplexing in the kernel.

The details of configuring the \acs{IPMI} driver are found in the
\verb=IPMI.txt= file in the kernel documentation; those details won't
be discussed here.

To use the \acs{IPMI} device driver, you open the \verb=/dev/ipmi0= or
\verb=/dev/ipmidev/0= file.  The driver allows multiple \acs{IPMI} devices
at the same time; you would increment the number to get to successive
devices.  However, most systems only have one.

The primary interface to the driver is through \verb=ioctl= calls.
\verb=read= and\verb=write= calls will not work because the \acs{IPMI}
driver separates the addressing and data for an \acs{IPMI} message.

The core description of an \acs{IPMI} message is:

\begin{verbatim}
struct ipmi_msg
{
        unsigned char  netfn;
        unsigned char  cmd;
        unsigned short data_len;
        unsigned char  *data;
};
\end{verbatim}

The \verb=netfn= describes \ac{NetFN} of the class of message being
sent.  \acs{IPMI} messages are grouped into different classes by
function.  The \verb=cmd= is the command within the class.  Chapter
\ref{ipmi-commands} discusses this is more detail.  The \verb=data=
and \verb=data_len= fields are the message contents.  This structure
is used in both sent and received messages.

\subsubsection{Sending Commands}
To send a command, use the following:

\begin{verbatim}
rv = ioctl(fd, IPMICTL_SEND_COMMAND, &req);
\end{verbatim}

The \verb=req= structure has the following format:

\begin{verbatim}
struct ipmi_req
{
        unsigned char   *addr;
        unsigned int    addr_len;
        long            msgid;
        struct ipmi_msg msg;
};
\end{verbatim}

The \verb=addr= and \verb=addr_len= fields describe the destination
address of the management controller to receive message.  The
\verb=msg= field itself gives the message to send.  The msgid is a
field for the user; the user may put any value they want in this
field.  When the response comes back for the command, it will contain
the message id.  Since it is a long value, it can be used to hold a
pointer value.

The driver guarantees that the user will receive a response for every
message that is successfully sent.  If the message times out or is
undeliverable, an error resonse will be generated and returned.

The following code fragment shows how to send a message to the local
management controller, in this case a command to read the value of a
sensor:

\begin{verbatim}
struct ipmi_req                   req;
unsigned char                     data[1];
struct ipmi_system_interface_addr si;

/* Format the address. */
si.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;
si.channel = IPMI_BMC_CHANNEL;
si.lun = 0;

req.addr = (void *) &si;
req.addr_len = sizeof(si);
req.msgid = 0x1234;
req.msg.netfn = 0x04; /* Sensor/Event netfn */
req.msg.cmd = 0x2d; /* Get sensor reading */
req.msg.data = data;
req.msg.data_len = 1;
data[1] = 10; /* Read sensor 10 */

rv = ioctl(fd, IPMICTL_SEND_COMMAND, &req);
\end{verbatim}

Note that sending the command is asyncronous; you will not immediately
get the response.  Instead, the response comes back later and can be
received at that point in time.  This is what makes the \verb=msgid=
important.

The following example shows sending a get device id request to \ac{IPMB}
address 0xb2.

\begin{verbatim}
struct ipmi_req       req;
struct ipmi_ipmb_addr si;

/* Format the address. */
si.addr_type = IPMI_IPMB_ADDR_TYPE;
si.channel = 0;
si.lun = 0;
si.slave_addr = 0xb2;

req.addr = (void *) &si;
req.addr_len = sizeof(si);
req.msgid = 0x1234;
req.msg.netfn = 0x06; /* App netfn */
req.msg.cmd = 0x01; /* Get device id */
req.msg.data = NULL;
req.msg.data_len = 0;

rv = ioctl(fd, IPMICTL_SEND_COMMAND, &req);
\end{verbatim}

\subsubsection{Receiving Responses and Events}
As mentioned before, the responses to commands come back in later.
You can use standard \verb=select= and \verb=poll= calls to wait for
messages to come in.  However, you cannot use \verb=read= to get the
message.  The following data structure is used to receive messages:

\begin{verbatim}
struct ipmi_recv
{
        int             recv_type;
        unsigned char   *addr;
        unsigned int    addr_len;
        long            msgid;
        struct ipmi_msg msg;
};
\end{verbatim}

The \verb=recv_type= field can be one of the following values:

\begin{description}
\item[IPMI\_RESPONSE\_RECV\_TYPE] A response to a sent command.
\item[IPMI\_ASYNC\_EVENT\_RECV\_TYPE] An asyncronous event.
\item[IPMI\_CMD\_RECV\_TYPE] A command was recevied for the system
software.
\item[IPMI\_RESPONSE\_RESPONSE\_TYPE] Responses sent by this
interface get acked using one of these.  This way you can tell if
there was an error sending the response.
\end{description}

Received commands are discussed in section \ref{recv-cmd-resp}.  You
have to fill in the data for the driver to put the received
information into.  The following shows how to receive a message:

\begin{verbatim}
unsigned char    data[IPMI_MAX_MSG_LENGTH];
struct ipmi_addr addr;
struct ipmi_recv recv;
int              rv;

recv.msg.data = data;
recv.msg.data_len = sizeof(data);
recv.addr = (unsigned char *) &addr;
recv.addr_len = sizeof(addr);
rv = ioctl(fd, IPMICTL_RECEIVE_MSG_TRUNC, &recv);
if (rv == -1) {
    if (errno == EMSGSIZE) {
        /* The message was truncated, handle it as such. */
        ...
    }
}
switch (recv.recv_type) {
case IPMI_RESPONSE_RECV_TYPE: ...
case IPMI_ASYNC_EVENT_RECV_TYPE: ...
case IPMI_CMD_RECV_TYPE: ...
case IPMI_RESPONSE_RESPONSE_TYPE: ...
\end{verbatim}

The \verb=msgid= comes in very handy for this responses, it lets you
easily correlate commands and responses.  It has no meaning for events.

The \verb=netfn= for a received message have a ``one'' bitwise or-ed
onto the value.  In \acs{IPMI}, even \acs{NetFN}s are always commands
and odd \acs{NetFN}s are always responses.

For responses, the address will always be the same as the sent
address.

A interface will not receive events by default.  You must register to
receive them with the following:

\begin{verbatim}
int val = 1;
rv = ioctl(fd, IPMICTL_SET_GETS_EVENTS_CMD, &val)
\end{verbatim}

Setting \verb=val= to true turns on events, setting it to false turns
off events.  Multiple users may register to receive events; they will
all get all events.  Note that this is for receiving asyncronous
events through the interface.  The events also go into the event log
as described in chapter \ref{events}, but that is a different thing.
If you receive an event through this interface, you will also get it
in the event log.  Section \ref{event-format} describes the format of
events.

\subsubsection{Receiving Commands and Responding}
\label{recv-cmd-resp}
Commands sent to \ac{LUN} two of a management controller will generally be
routed to the driver.  If the driver does not have a registered user
for that command, it will respond that it does not handle that
command.

If you wish to receive commands, you must register to receive those
commands.  The \verb=cmdspec= structure defines commands the program
wishes to receive:

\begin{verbatim}
struct ipmi_cmdspec
{
        unsigned char netfn;
        unsigned char cmd;
};
\end{verbatim}

These are registered with the following ioctl:

\begin{verbatim}
rv = ioctl(fd, IPMICTL_REGISTER_FOR_CMD, &cmdspec);
\end{verbatim}

To remove a registered command, use the following:

\begin{verbatim}
rv = ioctl(fd, IPMICTL_UNREGISTER_FOR_CMD, &cmdspec);
\end{verbatim}

If you receive a message, you must send a response.  The driver makes
this easy, you can always use the received address to send the
response to.  The program in Appendix \ref{recv-cmd-prog} receives one
message, sends a response, and exits.  When you response, you must
supply the \verb=msgid= that came into the command.

\subsubsection{Overriding Default Timing Values}
Be default, commands over \ac{IPMB} get resent up to 5 times with a 1
second timeout between the sends.  For very select applications, this
is not suitable.  Primarily, some applications need to only send once,
they have a higher-level resend mechanism and the OpenIPMI resends
will only get in the way.

Note that responses over \ac{IPMB} will not get timed or resent.

The user may modify the timing values two different ways.  The user
can set the default resend and retry times for a file descriptor with
the following structure:

\begin{verbatim}
struct ipmi_timing_parms
{
        int          retries;
        unsigned int retry_time_ms;
};
\end{verbatim}

The \verb=retries= parm is the number of times the message will be
resent.  The \verb=retry_time_ms= is the time in milliseconds between
resends.  To get and set the parameters, use the following:

\begin{verbatim}
struct ipmi_timing_parms tparms;

rv = ioctl(fd, IPMICTL_GET_TIMING_PARMS_CMD, &tparms);
if (rv == -1)
  error handling...

printf("parms were: %d %d", tparms.retries, tparms.retry_time_ms);

tparms.retries = 0; /* No resends */
tparms.retry_time = 1000; /* one second */
rv = ioctl(fd, IPMICTL_SET_TIMING_PARMS_CMD, &tparms);
if (rv == -1)
  error handling...
\end{verbatim}

This will set the timing parameters for all future messages.  You can
also override the timing on individual messages.

\begin{verbatim}
struct ipmi_req_settime
{
        struct ipmi_req req;

        int          retries;
        unsigned int retry_time_ms;
};
\end{verbatim}

The \verb=req= is the request as shown previously.  Use the following
ioctl to perform the request:

\begin{verbatim}
rv = ioctl(fd, IPMICTL_SEND_COMMAND_SETTIME, &req_time);
\end{verbatim}

\subsubsection{Setting Your Local \ac{IPMB} Address}
Unfortunately, \acs{IPMI} has no standard way to determing your local \ac{IPMB}
address.  It is usually set to 20h, but especially in bussed systems,
the local management controller may have a different address.

If you do not set your \ac{IPMB} address properly, messages out on the \ac{IPMB}
will not have the proper source address and thus the response will go
to the wrong place.  To avoid this problem, the OpenIPMI allows the
user to set the local \ac{IPMB} address and the local \ac{LUN}.  The following
shows how to get and set the \ac{IPMB} address:

\begin{verbatim}
unsigned int ipmb_addr;

rv = ioctl(fd, IPMICTL_GET_MY_ADDRESS_CMD, &ipmb_addr);
if (rv == -1)
  error handling...

printf("My address was: %x", ipmb_addr);

ipmb_addr = 0xb2;
rv = ioctl(fd, IPMICTL_SET_MY_ADDRESS_CMD, &ipmb_addr);
if (rv == -1)
  error handling...
\end{verbatim}

The driver also has ioctls to get and set the \ac{LUN}, but you should
almost certainly leave that alone.

\subsection{The OpenIPMI System Interface}
The OpenIPMI library system interface can be set up with the
following function:

\begin{verbatim}
int ipmi_smi_setup_con(int                if_num,
                       os_handler_t       *handlers,
                       void               *user_data,
                       ipmi_con_t         **new_con);
\end{verbatim}

The \verb=if_num= is the specific interface number.  Generally this is
\verb=0=, but if a system has more than one system interface then this
will be the specific interface number.  The \verb=handlers= is the OS
handler data to use for the connection (as described in section
\ref{openipmi-os-handlers}).  The \verb=user_data= field is put into
the \verb=user_data= filed in the \verb=ipmi_con_t= data structure.  A
new connection is returned in \verb=new_con=.

The OpenIPMI library understands how to get the local \ac{IPMB} address for
certain sytems.  If it can get the local \ac{IPMB} address, it will set it
automatically.

Once you have a connection, you can start it and use it directly.
However, usually you pass this to the domain startup code for creation
of a domain, as described in section \ref{creating-openipmi-domains}.

\section{Channels}

The \acs{IPMI} interfaces on a management controller are called
``channels''.  These are messaging channels.  \acs{LAN}, \ac{IPMB}, system
interface, and any other messaging interfaces will each have their own
channel on the \ac{MC}.

Messages directly sent to the local management controller do nor
require any type of channel information.  When the user sends a
message out to another interface, it must specify the channel.  This
is called ``bridging''.  Channels also may have some type of
configuration information such as users and passwords.

\begin{table}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
0h & Primary \acs{IPMB} & Channel 0 is the primary \acs{IPMB} bus on the
system.\\
\hline
1h-7h & \parbox{1in}{Implementation-specific} & These channel may be any
type of channel, including \acs{IPMB}, and \acs{LAN} interfaces.\\
\hline
8h-Dh & & Reserved\\
\hline
Eh & Present I/F & This specifies the channel the message is going over.
It's not really very useful, since you have to put the real channel in
the command to send a message to it.\\
\hline
Fh & System Interface & This specifies the system interface, but is
really never used.\\
\hline
\end{tabularx}
\caption{\label{channel-list}Channel Numbers}
\end{table}

\section{\acs{IPMB}}

\ac{IPMB} provides the main channel for transferring messages around an
\acs{IPMI} system.  It is a message bus that works somewhat like Ethernet,
it is a CSMA (carrier-sense multiple access) system.  However, it does
not have collision detection; so if two \ac{MC}s attempt to transmit at the
same time, both messages will be lost.  Because of this, \ac{IPMB} does not
scale very well; careful use needs to be made of the bandwith on the
bus.

The format of an \ac{IPMB} message of $n$ bytes is:

\begin{showmsg}
\hline
\msgitem{0}{Destination \acs{IPMB} address}
\msgitem{1}{Bits 0-1 - Destination \acs{LUN}\\
	    Bits 2-7 - \acs{NetFN}}
\msgitem{2}{Checksum for bytes 0-1}
\msgitem{3}{Source \acs{IPMB} address}
\msgitem{4}{Bits 0-1 - Source \acs{LUN}\\
	    Bits 2-7 - Sequence Number}
\msgitem{5}{Command}
\msgitem{6 .. n-2}{Message Contents}
\msgitem{n-1}{Checksum for the whole message}
\end{showmsg}

Unfortunately, \acs{IPMI} does not have any type of routing handling or
transparency of messages.  To send a message out on the \ac{IPMB}, you
encapsulate the entire \ac{IPMB} message in a \textit{Send Message}
command and send it over the proper channel.

Since \ac{IPMB} can lose messages, the OpenIPMI device driver
implements a resend mechanism on commands sent over \ac{IPMB}; if a
response is not seen withing a given period of time, the command will
be resent.  This will be done a few times before an error is returned.

\subsection{IPMB Broadcast}
One special type of message is the broadcast \ac{IPMB} message.  This
message is exactly like a normal \ac{IPMB} message, but it has a 0 byte
prepended to the message.  This can only be a \textit{Get Device Id}
command.  It is used to discover management controllers in the system.
Broadcast is a really bad name, because it will not actually
broadcast, it will go to the \ac{IPMB} address is the second byte of the
message.  This is used for discovery because it will not have any
effect on \acs{I$^2$C} devices on the bus, but \acs{IPMI} devices will
do a normal response.

Many IPMI systems do not correctly implement broadcast; it seems to be
an oft ignored part of the spec.

\subsection{OpenIPMI and \acs{IPMB}}
The OpenIPMI driver and library handle the details of IPMB for the
user.  To send a message over IPMB, the user create and OpenIPMI
\ac{IPMB} address as described in section\ref{openipmi-addressing} and
sends a normal OpenIPMI message.  The library and driver take care of
selecting the sequence numbers, formatting the messages, tracking and
decoding the response, and resending messages.

\section{ICMB}

TBD - write this.

\section{\acs{LAN}}
The \ac{IPMI} \acs{LAN} interface allows users to connect to \ac{IPMI}
systems over an Ethernet interface.  This can generally even be done
when the system is turned off, although it probably has to be plugged
in.  This lets you do things like power control the system and reset
the main processor even when the operating system is not operational
on the system.

The \ac{IPMI} \acs{LAN} protocol runs over a subset of the \ac{RMCP}
protocol.  \ac{RMCP} is defined in RMCP\cite{rmcp}.

The \ac{IPMI} \acs{LAN} is not well defined in the spec.  Many valid
interpretations of the spec were possible.  Some errata has been
issued, but that really only added one more possible interpretation.
OpenIPMI implements the three different common interpretations of the
spec.  They can interwork seamlessly, so it is not a problem.

TBD - describe the protocol in detail.

\subsection{\acs{LAN} Configuration}
\label{lan-config}
Most systems have tools to configure the \ac{IPMI} \acs{LAN}
interface.  IPMI has a built-in way to do this, too, through a set of
tables.

\subsubsection{\acs{LAN} Configuration Commands}
To set up the \acs{LAN} configuration table, the command shown in table
\ref{set-lan-conf-cmd} is used to set parameters.

\begin{showmsg}
\msgtag{Request}
\msgitem{0}{Bits 0-3 - Channel Number\\
	    Bits 4-7 - reserved}
\msgitem{1}{Parameter Selector.  This selects the entry in the table that you
	want to set.}
\msgitem{2-n}{The data for the parameter.  You must look up the entry in
	table \ref{lan-conf-parms} for the exact contents, it depends on
	which entry you are setting.}
\msgtag{Response}
\msgitem{0}{Completion code.  Standard completion codes, plus:\\
	80h - Parameter not supported\\
	81h - Attempt to set the ``set in progress' value (parm 0) when
		the parameter is not in the free (set complete) state.\\
	82h - Attempt to write a read-only parameter.}
\msgcaption{\label{set-lan-conf-cmd}Set \acs{LAN} Configuration Parameters
  Command, NetFN Transport (0Ch), Cmd 01h}
\end{showmsg}

Table \ref{get-lan-conf-cmd} shows the command used to get \acs{LAN}
parameters.

\begin{showmsg}
\msgtag{Request}
\msgitem{0}{Bits 0-3 - Channel Number\\
	    Bits 4-6 - reserved\\
	    Bit 7 - If 1, only get parameter revision}
\msgitem{1}{Parameter Selector.  This selects the entry in the table that you
	want to get.}
\msgitem{2}{Set Selector.  Some parameters are in an array, this tells which
	array element to set.  Set to zero if the parameter does not have a
	set selector.}
\msgitem{3}{Block Selector.  Some parameters have two levels of arrays
	(an array inside of the array).  The Set Selector is the first
	level array specifier, this is the second level.  No standard
	\acs{LAN} parameters use this, although OEM ones might.  Set to zero
	if the parameter does not have a block selector.}
\msgtag{Response}
\msgitem{0}{Completion code.  Standard codes, plus:\\
	80h - parameter not supported}
\msgitem{1}{Parameter revision.  Format is:\\
	Bits 0-3 - Oldest revision parameter is backward compatible with\\
	Bits 4-7 - Current parameter revision}
\msgitem{2-n}{Parameter data.  This will not be present if bit 7 of byte 0
	of the response is set to 1.  The contents of this depends on the
	particular parameter being fetched, see table \ref{lan-conf-parms}
	for the	parameters.}
\msgcaption{\label{get-lan-conf-cmd}Get \acs{LAN} Configuration Parameters
  Command, NetFN Transport (0Ch), Cmd 02h}
\end{showmsg}

\subsubsection{The \acs{LAN} Configuration Table}
\label{sec-lan-conf-parms}
The \acs{LAN} Configuration table has an unusual locking mechanism
(although it is usual for \acs{IPMI}).  Parameter zero is a lock.  If
you set the value to one, it will only succeed if the value is zero.
Thus, to lock the table, you set the value to one until it succeeds.
You then set it to zero when you are done.  This locking mechanism
leads to problem if the locker dies while it holds the lock, so you
probably need some way to override the lock if this happens.  The lock
does not actually keep anyone from changing the data, it is simply a
common mechanism to mutual exclusion.  Note also that the lock has a
``commit'' mechanism, writing two to the lock will commit the contents
if the system supports it.  If the system supports rollback, setting
the value to zero will rollback and not commit the changes you made.
So for correctness, you should write a two when you are complete, and
if that fails then write a zero.

All network parameters such as \acs{IP} address, port, and \acs{MAC}
address are in network order, also called big endian or most
significant byte first.  Unless marked ``volatile'', all of these
will survive removal of power.

\begin{longtable}{|p{0.2\textwidth}|l|p{0.65\textwidth}|}
\caption{\acs{LAN} Configuration Parameters\label{lan-conf-parms}}
\\ \hline
\bfseries{Parameter} & \bfseries{\#} & \bfseries{Description}\\
\endhead
\hline
Set In Progress (volatile) & 0 &
	Used to indicate that the parameters are being updated.
	Bits 2-7 are reserved.  Bits 0-1 have the following values:
	\begin{description}
	\item[00b] - set complete.  This is the state the system comes up in.
		This means that any user is finished updating the
		parameters.  If rollback is implemented, setting this
		value will cause any changes made since last setting
		this value to ``set in progress'' to be undone.
	\item[01b] - set in progress.  A user will set this value to inform
		others that it is updating these parameters.  This value
		can only be set if the current value is ``set complete''.
	\item[10b] - commit write (optional).  This will commit any changes
		that
		are pending and go to ``set complete'' state.  Some systems
		may not support this, if setting this returns an error you
		should set this value to ``set complete'' by hand.
	\end{description}\\
\hline
Authentication Type Support (Read only) & 1 &
	A read only field showing which authentication types are supported.
	The format for this is defined in table \ref{auth-bitmask}.\\
\hline
Authentication Type Enables & 2 &
	A 5 byte field that holds the allowed authentication type for each
	privilege level.  The bytes are:
	\begin{description}
	\item[byte 0] - callback
	\item[byte 1] - user
	\item[byte 2] - operator
	\item[byte 3] - admin
	\item[byte 4] - oem
	\end{description}
	The format for each byte is defined in table \ref{auth-bitmask}.\\
\hline
\acs{IP} Address & 3 &
	A 4 byte field holding the \acs{IP} address, in network order.  This
	is the local \acs{IP} address used for this particular channel.  You
	only need to set this is parameter 4 is set to ``static address''.\\
\hline
\acs{IP} Address Source & 4 &
	One byte field telling the BMC where to get its IP address. Bits 4-7
	are reserved.  Values for bits 0-3 are:
	\begin{description}
	\item[0] - unspecified (I don't know what that means)
	\item[1] - static address, configured from parameter 3
	\item[2] - get address from DHCP
	\item[3] - get address from BIOS or system software
	\item[4] - get address by some other method
	\end{description}
	As you probably can tell, static address and DHCP are really the
	only useful values.\\
\hline
\acs{MAC} Address & 5 &
	A 6 byte field.  This is the Ethernet \ac{MAC} address to use as the
	source when transmitting packets, in network order.  You must set
	this value properly.\\
\hline
Subnet Mask & 6 &
	A 4 byte field holding the subnet mask for the \acs{IP} connection,
	in network order.\\
\hline
IPv4 Header Parms & 7 &
	A 3 byte field controlling some parameters in the \acs{IP} header.
	The bytes are:
	\begin{description}
	  \item[byte 0] - time to live (default 40h) - The number of network
	    hops allowed for \acs{IP} packets sent by the \acs{BMC}.
	  \item[byte 1]
	    \begin{description}
	      \item[bits 0-4] - reserved
	      \item[bits 5-7] - flags.  Sets the of the flags field in the
		IP header.  The default value is 010b, or do not fragment.
	    \end{description}
	  \item[byte 2]  This is the setting of the 8-bit type of service
	    field in the \acs{IP} header. Only one of bits 1-4 should be
	    set.
	    \begin{description}
	    \item[bit 0] - unused, set to zero.
	    \item[bit 1] - minimize monetary cost
	    \item[bit 2] - maximize reliability
	    \item[bit 3] - maximize throughput
	    \item[bit 4] - minimize delay
	    \item[bits 5-7] - Precedence, which is unused by IP systems now.
	    \end{description}
	    The default value is 00010000b.
	\end{description}\\
\hline
Primary RMCP port number (optional) & 8 &
	A 2 byte field holding the \acs{UDP} port number to use for primary
	\acs{RMCP}.  Default value is 623.\\
\hline
Secondary RMCP port number (optional) & 9 &
	A 2 byte field holding the \acs{UDP} port number to use for the
	secure aux bus \acs{RMCP} port.  IPMI does not use this, but it is
	here for completeness.  Default value is 664.\\
\hline
\acs{BMC}-generated \acs{ARP} control (optional) & 10 &
	A 1 byte field controlling how the BMC generates \acs{ARP}s.  If a
	user attempts to set
	an unsupported field, the \acs{BMC} will return an error.  The
	bits are:
	\begin{description}
	\item[bit 0] - set to 1 to enable \acs{BMC} generated gratuitous
	  \acs{ARP}s.
	\item[bit 1] - set to 1 to enable \acs{BMC} generated \acs{ARP}
	  responses.
	\item[bits 2-7] - reserved
	\end{description}\\
\hline
Gratuitous \acs{ARP} interval (optional) & 11 &
	A one byte field holding the interval between gratuitous \acs{ARP}s.
	The interval is specified in 500 millisecond increments, with a 10\%
	accuracy.  If this is not implemented, the interval will be 2
	seconds.\\
\hline
Default gateway address & 12 &
	A 4 byte field holding the IP address of the default gateway, in
	network order.  The BMC will send packets to this address if the
	destination is not on its subnet, if this gateway is chosen as
	the gateway to use.\\
\hline
Default gateway \acs{MAC} address & 13 &
	A 6 byte filed holding the Ethernet MAC address to use in
	the destination when
	sending packets to the default gateway.\\
\hline
Backup gateway address & 14 &
	A 4 byte field holding the IP address of the backup gateway, in
	network order.  The BMC will send packets to this address if the
	destination is not on its subnet, if this gateway is chosen as
	the gateway to use.\\
\hline
Backup gateway \acs{MAC} address & 15 &
	A 6 byte filed holding the Ethernet MAC address to use in the
	destiination when
	sending packets to the backup gateway.\\
\hline
Community String & 16 &
	An 18 byte field holding the \acs{SNMP} community string to
	use in traps send by the BMC.  The default is ``public''.\\
\hline
Number of Destinations (read only) & 17 &
	The number of entries in the destination type and destination address
	tables in parameters 18 and 19.\\
\hline
Destination type & 18 &
	This is an array of destination types, each 4 bytes long.  The first
	byte in bits 0-3 is the index into the array, you put the index
	here when you set the value, and that index gets set.  This index
	comes from the alert policy entry destination field
	defined in table \ref{alert-policy-table-entry}.  Destination 0 is
	special and used by the Alert Immediate command as described in
	section \label{sec-alert-immediate}.  The fields are:
	\begin{description}
	\item[byte 0]
	  \begin{description}
	    \item[bits 0-3] - The index into the array
	    \item[bits 4-7] - reserved
	  \end{description}
	\item[byte 1] The destination type.  The bits are:
	  \begin{description}
	  \item[bits 0-2] - Destination type, values are:
	    \begin{description}
	    \item[000b] - PET Trap
	    \item[001b-101b] - reserved
	    \item[110b] - OEM 1
	    \item[111b] - OEM 1
	    \end{description}
	  \item[bits 3-6] - reserved
	  \item[bit 7] - If zero, the alert does not need to be acknowledged
	    to be considered successful.  If 1, the alert needs to be
	    acknowledged with a \acs{PET} Acknowledge Command as defined
	    in table \ref{pet-ack-cmd}.
	  \end{description}
	\item[byte 2] \acs{PET} Retry Time.  This specified the amount
	  of time between resends when waiting for an acknowledge of
	  the sent trap.
	\item[byte 3] Max \acs{PET} Retries.
	  \begin{description}
	  \item[bits 0-2] - The maximum number of retries of a trap before
	    giving up.
	  \item[bits 3-7] - reserved
	  \end{description}
	\end{description}\\
\hline
Destination address & 19 &
	This is an array of destination address, each 13 bytes long.  The
	first byte in bits 0-3 is the index into the array, you put the index
	here when you set the value, and that index gets set.  This index
	comes from the alert policy entry destination field
	defined in table \ref{alert-policy-table-entry}. Destination 0 is
	special and used by the Alert Immediate command as described in
	section \label{sec-alert-immediate}.  The fields are:
	\begin{description}
	\item[byte 0]
	  \begin{description}
	    \item[bits 0-3] - The index into the array
	    \item[bits 4-7] - reserved
	  \end{description}
	\item[byte 1] The address format:
	  \begin{description}
	    \item[bits 0-3] - The address type, 0h is the only valid
	      value, specifying IP.
	    \item[bits 4-7] - reserved
	  \end{description}
	\item[byte 2] Gateway selector
	  \begin{description}
	  \item[bit 0]
	    \begin{description}
	    \item[0] - use the default gateway
	    \item[0] - use the backup gateway
	    \item[bits 1-7] - reserved
	    \end{description}
	  \end{description}
	\item[bytes 3-6] The \acs{IP} address to send the alert to when using
	  this destination, in network order.
	\item[bytes 7-12] The Ethernet \acs{MAC} address to send the alert
	  to when using this destination, in network order.
	\end{description}\\
\hline
OEM & 192+ &
	Parameters 192 to 255 are OEM parameters.  The rest of the
	parameters are reserved.\\
\hline
\end{longtable}

\subsection{ARP control}

TBD - write this, include command, talk about config table entries.

\subsection{OpenIPMI \acs{LAN} Configuration}
OpenIPMI has some support for handling the \acs{LAN} configuration.
This is defined in the \verb=ipmi_lanparm.h= include file; it has all
the details on how to use this.

To configure the \acs{LAN} parameters for a BMC, you must first
allocate a lanparm structure with:
\begin{verbatim}
int ipmi_lanparm_alloc(ipmi_mc_t      *mc,
                       unsigned int   channel,
                       ipmi_lanparm_t **new_lanparm);
\end{verbatim}

The channel is the \acs{IPMI} channel number of the \acs{LAN} port you are
configuring.  Generally, if a server has more than one port, it will
have a separate channel for each port, you will have to find the
channel numbers from the manufacturer, although channels 6 and 7 are
commonly used as the \acs{LAN} channels.

Once you have a \verb=lanparm= structure, you can get and set
individual parms assuming you follow all the rules associated with the
configuration table.  However, there is a much easier way that
OpenIPMI provides.  After you have allocated a \verb=lanparm=
structure these, the function:
\begin{verbatim}
typedef void (*ipmi_lan_get_config_cb)(ipmi_lanparm_t    *lanparm,
				       int               err,
				       ipmi_lan_config_t *config,
				       void              *cb_data);
int ipmi_lan_get_config(ipmi_lanparm_t         *lanparm,
			ipmi_lan_get_config_cb done,
			void                   *cb_data);
\end{verbatim}
will fetch the full current configuration.  Note that when you call
this, you will be holding a lock if it succeeds.  You must release the
lock when you are done, or no one else will be able to change the
configuration unless they forcefully remove your lock.

At this point, you can change the value in the \verb=config=
structure.  But those changes are only local.  When you have complete
making the changes, you must commit them back to the BMC.  To do this,
call:
\begin{verbatim}
int ipmi_lan_set_config(ipmi_lanparm_t       *lanparm,
			ipmi_lan_config_t    *config,
			ipmi_lanparm_done_cb done,
			void                 *cb_data);
\end{verbatim}
After this point in time, the \verb=config= cannot be used for future
set operation, because it has been committed.  You must re-read it to
modify parameters again.

If you do not wish to modify the configuration, you still need to
clear the lock.  Do that with:
\begin{verbatim}
int ipmi_lan_clear_lock(ipmi_lanparm_t       *lanparm,
			ipmi_lan_config_t    *config,
			ipmi_lanparm_done_cb done,
			void                 *cb_data);
\end{verbatim}

Once you are done with the \verb=config= structure, you must free it with:
\begin{verbatim}
void ipmi_lan_free_config(ipmi_lan_config_t *config);
\end{verbatim}

When you are done with a \verb=lanparm= structure, you must free it with:
\begin{verbatim}
int ipmi_lanparm_destroy(ipmi_lanparm_t       *lanparm,
			 ipmi_lanparm_done_cb handler,
			 void                 *cb_data);
\end{verbatim}
If the \verb=lanparm= structure currently has operations pending on
it, the destroy will be delayed until those operations are complete.
The handler will be called when the actual destroy takes place.

\subsection{The OpenIPMI \acs{LAN} Interface}
The \acs{LAN} interface is complicated, but OpenIPMI handles most of the
details for the user.  A single function sets up the interface.
Unfortunately, that function takes a huge number of parameters due to
the large number of things required to configure a \ac{IPMI} \acs{LAN}
connection.  The function is:

\begin{verbatim}
int ipmi_ip_setup_con(char         * const ip_addrs[],
                      char         * const ports[],
                      unsigned int num_ip_addrs,
                      unsigned int authtype,
                      unsigned int privilege,
                      void         *username,
                      unsigned int username_len,
                      void         *password,
                      unsigned int password_len,
                      os_handler_t *handlers,
                      void         *user_data,
                      ipmi_con_t   **new_con);
\end{verbatim}

The parameters are:

\begin{description}
\item[\texttt{ip\_addrs}] An array of \acs{IP} addresses.  Each \acs{IP}
address must be an address that connects to the exact same management
controller.
If you need connections to multiple management controllers, you must set
up two different connections and use multiple connections in the domain.
\item[\texttt{ports}] An array of \acs{UDP} ports for each IP address.  This is
defined as 623 in the \acs{IPMI} spec, but is here for flexibility.
\item[\texttt{num\_ip\_addrs}] The number of IP addresses and ports.
\item[\texttt{authtype}] The authentication type to use for the connection.
Table \ref{ipmi-authtypes} describes the different authentication types.
\item[\texttt{privilege}] The privilege level to connect at.  Table
\ref{ipmi-priv-levels} describes the different privilege levels.
\item[\texttt{username}] The username to connect as.  See section
\ref{user-mgmt} for details on users.
\item[\texttt{username\_len}] The length of the username.  Required because
usernames can be binary and contain zeros.
\item[\texttt{password}] The password for the user.  See section \ref{user-mgmt}
for details on users.
\item[\texttt{password\_len}] The length of the password.  Required because
usernames can be binary and contain zeros.
\item[\texttt{handlers}] The OS handler to use for this domain.  See section
\ref{openipmi-os-handlers} for more details.
\item[\texttt{user\_data}] This is a field that will be put into the connection
data structure of the same name.  This is for user use and OpenIPMI will
not use it.
\item[\texttt{new\_con}] The new connection is returned in this field.
\end{description}

Once you have a connection, it works like a normal connection as 
defined in section \ref{openipmi-generic-interface}.

\section{Serial}

\subsection{Direct Serial}

\subsection{Serial over \acs{PPP}}

\begin{longtable}{|p{0.2\textwidth}|l|p{0.65\textwidth}|}
\caption{Serial Configuration Parameters\label{serial-conf-parms}}
\\ \hline
\bfseries{Parameter} & \bfseries{\#} & \bfseries{Description}\\
\endhead
\hline
\end{longtable}

\section{User Management}
\label{user-mgmt}

\begin{table}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\verb=IPMI_AUTHTYPE_NONE= & No authentication.\\
\hline
\verb=IPMI_AUTHTYPE_MD2= & \acs{MD2} style authentication.\\
\hline
\verb=IPMI_AUTHTYPE_MD5= & \acs{MD5} style authentication.  This is the
recommended type of authentication.\\
\hline
\verb=IPMI_AUTHTYPE_STRAIGHT= & Puts the password into the message in
plain text.  Don't use this.\\
\hline
\end{tabularx}
\caption{\label{ipmi-authtypes}Authentication types in IPMI}
\end{table}

\begin{table}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\verb=IPMI_PRIVILEGE_CALLBACK= & The user is only allowed to request
that the IPMI system call back home.\\
\hline
\verb=IPMI_PRIVILEGE_USER= & A ``read-only'' user.  The user can look
at system state, but not change anything.  For instance, the user can
fetch \acs{SEL} entries, but not delete them.\\
\hline
\verb=IPMI_PRIVILEGE_OPERATOR= & This user can do everything but configuration
commands.  For instance, they can clear the SEL and configure sensors, but
they cannot add users or configure \acs{LAN} parameters.\\
\hline
\verb=IPMI_PRIVILEGE_ADMIN= & This user can do pretty much anything on an
IPMI system.\\
\hline
\verb=IPMI_PRIVILEGE_OEM= & Undefined by the spec, it's whatever the \acs{OEM}
wants.\\
\hline
\end{tabularx}
\caption{\label{ipmi-priv-levels}Privilege levels in IPMI}
\end{table}

\begin{table}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
0 & no authentication\\
\hline
1 & MD2 authentication\\
\hline
2 & MD5 authentication\\
\hline
3 & reserved\\
\hline
4 & straight password authentication\\
\hline
5 & OEM authentication\\
\hline
6-7 & reserved\\
\hline
\end{tabularx}
\caption{\label{auth-bitmask}Authentication bitmask often used in \acs{IPMI}}
\end{table}

\section{The \acs{PEF} Table and \acs{SNMP} Traps}

Many \ac{IPMI} systems can specify that certain operations be done
when an event comes in.  This can depend on the event's contents;
different actions can be done for different sets of events.  This is
done with the \acf{PEF} configuration.  Not all \acs{IPMI} systems can
do event filtering, but ones that do will work as this section
describes.

The \ac{PEF} configuration allows several different actions to be
perform when an IPMI event comes in (or when the BMC powers up and
there are pending events in its event queue).  Except for sending an
alert, if multiple event filters match, the higher priority action
will be done and the lower priority action will be ignores.  The
actions are:

\noindent\begin{tabularx}{\textwidth}{|p{0.2\textwidth}|l|X|}
\hline
\bfseries{Action} & \bfseries{Priority} & \bfseries{Description}\\
\hline
power down & 1 & (optional) Power the system down.\\
\hline
power cycle & 2 & (optional) Power off the system, then power it back on.\\
\hline
reset & 3 & (mandatory) Reset the main processor in the system.\\
\hline
Diagnostic Interrupt & 4 & (optional) Send a system-defined diagnostic
	interrupt to the main processor in the system.  This is generall
	an \ac{NMI}.\\
\hline
Send Alert & 5 & Send an alert of some type, via an \acs{SNMP} trap,
	a page, or a modem dialin.  Note that unlike the rest of the
	actions, this action will still be done if a higher priority
	action is done.  Alerts can also be prioritized via the
	Alert Policy Table as described in section \ref{sec-pef-conf-parms}.\\
\hline
\acs{OEM} & \acs{OEM} & (optional) Priority is defined by the \acs{OEM}.\\
\hline
\end{tabularx}

This sections will mainly focus on sending SNMP traps with alerts,
although the other parts will also be covered.  The \acs{PEF}
configuration can specify sending \acs{SNMP} traps to inform the the
management system that something has happened.  Generally, it is
saying that an event has been placed into the event log.  Most of the
event information is in the SNMP trap, but unfortunately, some key
information is not there.  It does give the system an immediate
notification.

To have a system send traps, two tables must be set up.  The \acs{LAN}
configuration table described in section \ref{lan-config} has
parameters to set the \acs{SNMP} community string and the trap
destination addresses available.  The \ac{PEF} table contains
information about how to filter traps.  Different events can cause
different traps to be sent to different places.  As well, specific
events can do other things, such as reset or power off the system.
The thing we are interested in is the ``Alert'' capability.

Note that alerts can also cause telephone pages, serial dialups and
things like that to happen.  They are pretty flexible, although this
section will mostly focus on \acs{SNMP} traps.

\subsection{\acs{PEF} and Alerting Commands}

These commands control the \ac{PEF} and alerting capabilities of a
system.

Table \ref{get-pef-cap-cmd} shows the command used to find out what
alert capabilities a BMC has.

\begin{showmsg}
\msgtag{Request}
\msgitem{-}{-}
\msgtag{Response}
\msgitem{0}{Completion Code}
\msgitem{1}{\acs{PEF} version, encoded as:
	\begin{description}
	\item[bits 0-3] - Major version \#
	\item[bits 4-7] - Minor version \#
	\end{description}}
\msgitem{2}{Supported PEF actions, if the bit is one then the action is
	supported:
	\begin{description}
	\item[bit 0] - alert
	\item[bit 1] - power down
	\item[bit 2] - reset
	\item[bit 3] - power cycle
	\item[bit 4] - OEM action
	\item[bit 5] - diagnostic interrupt
	\item[bits 6-7] - reserved
	\end{description}}
\msgitem{3}{Number of entries in teh event filter table}
\msgcaption{\label{get-pef-cap-cmd}Get \acs{PEF} Capabilities Command,
  NetFN S/E (04h), Cmd 10h}
\end{showmsg}

Table \ref{set-pef-conf-cmd} shows the command used to set the
\acs{PEF} configuration parameters in a BMC.

\begin{showmsg}
\msgtag{Request}
\msgitem{0}{Parameter Selector.  This selects the entry in the table that you
	want to set.}
\msgitem{1-n}{The data for the parameter.  You must look up the entry in
	table \ref{pef-conf-parms} for the exact contents, it depends on
	which entry you are setting.}
\msgtag{Response}
\msgitem{0}{Completion code.  Standard completion codes, plus:\\
	80h - Parameter not supported\\
	81h - Attempt to set the ``set in progress' value (parm 0) when
		the parameter is not in the free (set complete) state.\\
	82h - Attempt to write a read-only parameter.}
\msgcaption{\label{set-pef-conf-cmd}Set \acs{PEF} Configuration Parameters
  Command, NetFN S/E (04h), Cmd 12h}
\end{showmsg}

Table \ref{get-pef-conf-cmd} shows the command used to get \acs{PEF}
configuration parameters in a BMC.

\begin{showmsg}
\msgtag{Request}
\msgitem{0}{\begin{description}
	\item[bits 0-6] - Parameter Selector.  This selects the entry in the
	  table that you want to get.\\
	\item[bit 7] - If 1, only get parameter revision
	\end{description}}
\msgitem{1}{Set Selector.  Some parameters are in an array, this tells which
	array element to set.  Set to zero if the parameter does not have a
	set selector.}
\msgitem{2}{Block Selector.  Some parameters have two levels of arrays
	(an array inside of the array).  The Set Selector is the first
	level array specifier, this is the second level.  Set to zero
	if the parameter does not have a block selector.}
\msgtag{Response}
\msgitem{0}{Completion code.  Standard codes, plus:\\
	80h - parameter not supported}
\msgitem{1}{Parameter revision.  Format is:\\
	Bits 0-3 - Oldest revision parameter is backward compatible with\\
	Bits 4-7 - Current parameter revision}
\msgitem{2-n}{Parameter data.  This will not be present if bit 7 of byte 0
	of the response is set to 1.  The contents of this depends on the
	particular parameter being fetched, see table \ref{pef-conf-parms}
	for the	parameters.}
\msgcaption{\label{get-pef-conf-cmd}Get \acs{PEF} Configuration Parameters
  Command, NetFN S/E (04h), Cmd 13h}
\end{showmsg}

Table \ref{pet-ack-cmd} shows the command used to send an acknowledge
for a received trap.  If the ``Alert Acknowledge'' bit is set in
``Destination Type'' entry of the \acs{LAN} Configuration Table (Table
\ref{lan-conf-parms}) or in the `` ``Destination Info'' entry of the
Serial Configuration Table (Table \ref{serial-conf-parms}), then the
receiver of the trap must send this message to stop the resends.

\begin{showmsg}
\msgtag{Request}
\msgitem{0-1}{Sequence Number, from the field in the \ac{PET} of the trap
  being acknowledged.  Least significant byte first.}
\msgitem{2-5}{Local Timestamp, from the field in the \ac{PET} of the trap
  being acknowledged.  Least significant byte first.}
\msgitem{6}{Event Source Type, from the field in the \ac{PET} of the trap
  being acknowledged}
\msgitem{7}{Sensor Device, from the field in the \ac{PET} of the trap
  being acknowledged}
\msgitem{8}{Sensor Number, from the field in the \ac{PET} of the trap
  being acknowledged}
\msgitem{9-11}{Event Data 1-3, from the field in the \ac{PET} of the trap
  being acknowledged}
\msgtag{Response}
\msgitem{0}{Completion Code}
\msgcaption{\label{pet-ack-cmd}\acs{PET} Acknowledge Command,
  NetFN S/E (04h), Cmd 17h}
\end{showmsg}

\subsection{The \acs{PEF} Postpone Timer}

TBD - write this.

\subsection{\acs{PEF} Configuration Parameters}
\label{sec-pef-conf-parms}

The \acs{PEF} Configuration table has an unusual locking mechanism
(although it is usual for \acs{IPMI}).  Parameter zero is a lock.  If
you set the value to one, it will only succeed if the value is zero.
Thus, to lock the table, you set the value to one until it succeeds.
You then set it to zero when you are done.  This locking mechanism
leads to problem if the locker dies while it holds the lock, so you
probably need some way to override the lock if this happens.  The lock
does not actually keep anyone from changing the data, it is simply a
common mechanism to mutual exclusion.  Note also that the lock has a
``commit'' mechanism, writing two to the lock will commit the contents
if the system supports it.  If the system supports rollback, setting
the value to zero will rollback and not commit the changes you made.
So for correctness, you should write a two when you are complete, and
if that fails then write a zero.

Table \label{perf-conf-parms} has the parameters used to configure the
event filter. Unless marked ``volatile'', all of these will survive
removal of power.

\begin{longtable}{|p{0.2\textwidth}|l|p{0.65\textwidth}|}
\caption{\acs{PEF} Configuration Parameters\label{pef-conf-parms}}
\\ \hline
\bfseries{Parameter} & \bfseries{\#} & \bfseries{Description}\\
\endhead
\hline
Set In Progress (volatile) & 0 &
	Used to indicate that the parameters are being updated.
	Bits 2-7 are reserved.  Bits 0-1 have the following values:
	\begin{description}
	\item[00b] - set complete.  This is the state the system comes up in.
		This means that any user is finished updating the
		parameters.  If rollback is implemented, setting this
		value will cause any changes made since last setting
		this value to ``set in progress'' to be undone.
	\item[01b] - set in progress.  A user will set this value to inform
		others that it is updating these parameters.  This value
		can only be set if the current value is ``set complete''.
	\item[10b] - commit write (optional).  This will commit any changes
		that
		are pending and go to ``set complete'' state.  Some systems
		may not support this, if setting this returns an error you
		should set this value to ``set complete'' by hand.
	\end{description}\\
\hline
\acs{PEF} Control & 1 &
	One byte field global control bits for the \acs{PEF}:
	\begin{description}
	\item[bit 0] - Set to one to enable the PEF.
	\item[bit 1] - Set to one to cause event messages to be sent for
	  each action triggered by a filter.  These events are send as the
	  System Event Sensor (12h), offset 04h, see table
	  \ref{sensor-type-codes}.  Note that these events are subject
	  to PEF filtering, so be careful not to cause an infinite
	  event message send.
	\item[bit 2] - PEF Startup Delay Enable (optional).  When set
	  to one, this bit enables a PEF startup delay on manual
	  startup of a chassis and on all system resets.  If this bit
	  is supported, the spec says that the implementation must
	  supply a way for the user to diable the PEF in case the filter
	  entries are causing an infinite loop.  I have no idea what that
	  means.  If this bit is not implemented, the spec says that there
	  must always be a startup delay.  Parameter 3 of this table
	  sets the time.
	\item[bit 3] - PEF Alert Startup Delay Enable (optional).  When
	  set to one, this bit enables a delay between startup time and
	  when alerts are allowed to be sent.  Parameter 4 of this table
	  sets the time.
	\item[bits 4-7] - reserved
	\end{description}\\
\hline
\acs{PEF} Action Global Control & 2 &
	A one byte field for controlling whether specific \acs{PEF} actions
	are enabled at all.  If the bit is set to one, it is enabled.  The
	bits are:
	\begin{description}
	\item[bit 0] - alert
	\item[bit 0] - power down
	\item[bit 0] - reset
	\item[bit 0] - power cycle
	\item[bit 0] - OEM
	\item[bit 0] - diagnostic interrupt
	\item[bits 6-7] - reserved
	\end{description}\\
\hline
PEF Startup Delay (optional) & 3 &
	A one byte field giving the \acs{PEF} startup delay, in
	seconds, 10\% accuracy.  A zero value means no delay.  This
	goes along with bit 2 of byte 1 of parameter 1 of this table,
	see that for more details.\\
\hline
PEF Alert Startup Delay (optional) & 4 &
	A one byte field giving the \acs{PEF} Alert startup delay, in
	seconds, 10\% accuracy.  A zero value means no delay.  This
	goes along with bit 3 of byte 1 of parameter 1 of this table,
	see that for more details.\\
\hline
Number of Event Filters (read only) & 5 &
	The number of array entries in the event filter table, parameter
	6 of this table.  The bits are:
	\begin{description}
	\item[bits 0-6] - The number of event filter entries.  A zero
	  here means that events filters are not supported.
	\item[bit 7] - reserved
	\end{description}\\
\hline
Event Filter Table & 6 &
	This is a 21 byte field giving access to the event filter table.
	\begin{description}
	\item[byte 0]
	  \begin{description}
	  \item[bits 0-6] - The set selector, the array index of which
	    event filter to set.  00h is reserved and not used and does
	    not count in the number of event filters.
	  \item[bit 7] - reserved
	  \end{description}
	\item[bytes 1-20] - The filter data for the array element given
	  by byte 1 of this parameter.  See table \ref{pef-table-entry}
	  for the contents of this data.
	\end{description}\\
\hline
Event Filter Table Byte 1 & 7 &
	This is a 2 byte field giving access to the first byte of an
	event filter table entry.  This makes it convenient to set the
	first byte without having to read-modify-write the whole entry.
	\begin{description}
	\item[byte 0]
	  \begin{description}
	  \item[bits 0-6] - The set selector, the array index of which
	    event filter to set.  00h is reserved and not used and does
	    not count in the number of event filters.
	  \item[bit 7] - reserved
	  \end{description}
	\item[byte 1] - Byte 1 of the event filter table entry.  See
	  table \ref{pef-table-entry} for the contents of this data.
	\end{description}\\
\hline
Number of Alert Policies (read only) & 7 &
	The number of array entries in the alert policy table, parameter
	9 of this table.  The bits are:
	\begin{description}
	\item[bits 0-6] - The number of event filter entries.  A zero
	  here means that alert policies are not supported.
	\item[bit 7] - reserved
	\end{description}\\
\hline
Alert Policy Table & 8 &
	This is a 4 byte field giving access to the alert policy table.
	\begin{description}
	\item[byte 0]
	  \begin{description}
	  \item[bits 0-6] - The set selector, the array index of which
	    alert policy to set.  00h is reserved and not used and does
	    not count in the number of event filters.
	  \item[bit 7] - reserved
	  \end{description}
	\item[bytes 1-3] - The filter data for the array element given
	  by byte 1 of this parameter.  See table
	  \ref{alert-policy-table-entry}
	  for the contents of this data.
	\end{description}\\
\hline
System \acs{GUID} & 9 &
	A 17 byte field telling how to get the system \acs{GUID} for \acs{PET}
	traps.
	\begin{description}
	\item[byte 0]
	  \begin{description}
	  \item[bit 0] - If one, use the value in bytes 1-16 of this field
	    as the \acs{GUID} in traps.  If not set, use the value returned
	    from the Get System \acs{GUID} command.
	  \item[bits 1-7] - reserved
	  \end{description}
	\item[bytes 1-16] - The system \acs{GUID}
	\end{description}\\
\hline
Number of Alert String Keys (read only) & 11 &
	The number of array entries in the alert string keys, parameter
	12 of this table.  The bits are:
	\begin{description}
	\item[bits 0-6] - The number of alert string keys.  A zero
	  here means that alert policies are not supported.
	\item[bit 7] - reserved
	\end{description}\\
\hline
Alert String Keys (some parts are volatile) & 12 &
	Some actions require alert strings for paging an operator.  This
	key is used in conjunction with the alert policy table (table
	\ref{alert-policy-table-entry}) in some cases.  If bit 7 of byte
	3 of an alert policy table entry is set to 1, then it will use
	the alert string set field from that table and the event filter
	number from the event being processed to search this table.
	If it finds a match, it will use the alert string that corresponds
	with the same index as the entry in this table.

	For instance, if entry 4h of this table has a 3h in byte 1 and
	a 7h in byte 2, if event filter 4 matches an event and the
	alert policy used has 87h in byte 3, then the alert string
	entry 4h of the alert strings are used.
	\begin{description}
	\item[byte 0]
	  \begin{description}
	  \item[bits 0-6] - The set selector, the array index of which
	    alert key to set.  Entry 0h is volatile and used by the
	    Alert Immediate command as described in section
	    \label{sec-alert-immediate}.  Entries 1h-7h are
	    non-volatile.  All other entries are reserved.
	  \item[bit 7] - reserved
	  \end{description}
	\item[byte 1]
	  \begin{description}
	  \item[bits 0-6] - Event filter number to match
	  \item[bit 7] - reserved
	  \end{description}
	\item[byte 2]
	  \begin{description}
	  \item[bits 0-6] - Alert String Set to match
	  \item[bit 7] - reserved
	  \end{description}
	\end{description}\\
\hline
Alert Strings (some parts are volatile) & 13 &
	Some actions require alert strings for paging an operator.
	This table holds the actual alert strings.  This table is
	indexed by the alert policy table (table
	\ref{alert-policy-table-entry}) either directly if bit 7 of
	byte 3 of an alert policy table entry is set to 0, or indirectly
	through parameter 12 of this table if that bit is one.

	The meanings of the values in this table are dependend on the
	alert type and channel.

	For dial paging, this string will have a carraige return
	automatically appended to the string.

	For TAP paging, this string corresonds to 'Field 2', the pager
	message.  Note that TAP only supports 7-bit ASCII and the
	\acs{BMC} will zero the high bit when doing TAP paging.

	\begin{description}
	\item[byte 0]
	  \begin{description}
	  \item[bits 0-6] - The set selector, the array index of which
	    alert string to set.  Entry 0h is volatile and used by the
	    Alert Immediate command as described in section
	    \label{sec-alert-immediate}.  Entries 1h-7h are
	    non-volatile.  All other entries are reserved.
	  \item[bit 7] - reserved
	  \end{description}
	\item[byte 1] - Block selector.  The strings may be much larger than
	  can be set in a single message.  This selects which block to
	  write, in 16-byte increments.  So, a 0 here is the first 16 bytes,
	  a 1 is the second 16 bytes, and so on.
	\item[byte 2-n] - The bytes to write into the specific block
	  If this is less than 16 bytes, then only the given number of
	  bytes are written.
	\end{description}\\
\hline
OEM Parmeters & 96+ &
	Parameters 96-127 are allowed for OEM use.  All other parameters
	are reserved.\\
\hline
\end{longtable}

The \ac{PEF} table is read and written as part of the PEF
Configuration table, parameter 6, but the contents are documented
separately in table \ref{pef-table-entry}.  When and event comes in,
it is compared against each filter in order.  If a match occurs on
multiple filters, then the highest priority action is done and the
rest except for alerts are ignored.  After the operation is complete,
any alert operations are done by scanning the alert policy table in
order.  The order of the alert policy table defines the priority of
the different alerts.

\begin{longtable}{|l|p{0.2\textwidth}|p{0.65\textwidth}|}
\caption{\acs{PEF} Table Entry\label{pef-table-entry}}
\\ \hline
\bfseries{Byte} & \bfseries{Field} & \bfseries{Description}\\
\endhead
\hline
0 & Filter Configuration &
	Bits that control the operation of this filter:
	\begin{description}
	\item{bits 0-4} - reserved
	\item{bits 5-6} - filter type
	  \begin{description}
	  \item[00b] - Software configurable filter.  A manging system may
	    configure all parts of this filter.
	  \item[01b] - reserved
	  \item[10b] - pre-configured filters.  A managing system should
	    not modify the contents of this filter, although it may turn
	    on and off the filter using bit 7 of this field.
	  \item[11b] - reserved
	  \end{description}
	\end{description}\\
\hline
1 & Event filter action &
	These bits set what action this filter will do if it matches.
	These bits are enable if set to one.
	\begin{description}
	\item[bit 0] - alert
	\item[bit 1] - power off
	\item[bit 2] - reset
	\item[bit 3] - power cycle
	\item[bit 4] - OEM action
	\item[bit 5] - diagnostic interrupt
	\item[bits 6-7] - reserved
	\end{description}\\
\hline
2 & Alert Policy Number &
	\begin{description}
	\item[bits 0-3] - If alert is selected in byte 1, this chooses the
	  policy number to use in the alert policy table.
	\item[bits 4-7] - reserved
	\end{description}\\
\hline
3 & Event Severity &
	This is the value that will be put into the event severity field
	of the \ac{PET} trap.  If more than one event filter matches, the
	highest priority in all event filters will be used.  Valid values
	are:
	\begin{description}
	\item[00h] - unspecified
	\item[01h] - monitor
	\item[02h] - information
	\item[04h] - OK (returned to OK condition)
	\item[08h] - non-critical condition
	\item[10h] - critical condition
	\item[20h] - non-recoverable condition
	\end{description}\\
\hline
4 & Generator ID byte 1 &
	This matches the slave address or software id in the event.
	It must be an exact match.  Use FFh to ignore this field when
	comparing events.\\
\hline
5 & Generator ID byte 2 &
	This matches the channel and LUN in the event.  It must be an
	exact match.  Use FFh to ignore this field when comparing events.\\
\hline
6 & Sensor type &
	This matches the sensor type field in the event.  It must be an
	exact match.  Use FFh to ignore this field when comparing events.\\
\hline
7 & Sensor Number &
	This matches the sensor number field in the event.  It must be an
	exact match.  Use FFh to ignore this field when comparing events.\\
\hline
8 & Event Trigger &
	This matches the event direction and event type byte (byte 13)
	in the event.  It must be an
	exact match.  Use FFh to ignore this field when comparing events.\\
\hline
9-10 & Event data 1 low nibble values &
	This field is a bitmask specifying which values in the low 4 bits
	of the event data 1 field will match.  If a bit is set, then the
	corresponding value will match for this filter.  For instance, if
	bits 2 and 7 are set, then a value of 2 or 7 in the low nibble
	of event data 1 will cause a filter match (if everything else
	matches too, of course).
	\begin{description}
	\item[byte 9] - bit positions 0-7
	\item[byte 10] - bit positions 8-15
	\end{description}\\
\hline
11 & Event data 1 AND mask &
	This bit indicates which bits in event data 1 are used for
	comparison.  If a bit in the mask is zero, then the bit is not
	used for comparison.  if a bit is one, then the corresponding
	bit in event data 1 is used for comparison using
	the next two bytes of the table.\\
\hline
12 & Event data 1 compare 1 &
	This byte tells how the bits in event data 1 are compared.  For
	every bit set to one in this byte and one in the AND mask, the
	corresponding bit in event data 1 must exactly match the data
	in the compare 2 field.  For all bits set to zero in this byte
	and one in the AND mask, if any of those bits must be set to the
	same value as the bit in the compare 2 field, it is considered
	a match for that byte.

	For instance, if the AND mask is 00001111b, the compare 1 field
	is 00001100b, and the compare 2 field is 00001010b, then the
	event data 1 byte matches this comparison if:
	\begin{verbatim}
	  ((bit0 == 0) || (bit1 == 1))
	  && (bit2 == 0) && (bit3 == 1)
	\end{verbatim}
	Because there are zeroes in bits 4-7, those are not used in the
	mask.  Exact matches are required in bits 2 and 3 to compare 2,
	and one of bits 0 and 1 must be set the same as compare 2.

	Setting bytes 11-13 to all zero will cause event data 1 to be
	ignored for comparison (it will always match).\\
\hline
13 & Event data 1 compare 2 &
	This byte is used to compare the values of event data 1.  See
	byte 12 for more details on how this works.\\
\hline
14-16 & Event data 2 fields &
	These bytes work the same a bytes 11-13, but apply to event data
	2.  See those fields for details.\\
\hline
17-19 & Event data 3 fields &
	These bytes work the same a bytes 11-13, but apply to event data
	3.  See those fields for details.\\
\hline
\end{longtable}

The Alert Policy table tells the \acs{BMC} what to do when an event filter
matches and the alert action is set.  Every matching filter with the
alert action sets that alert policy to be run.  Once all the filters
have been checked, the set alert policies are checked and executed in
order of their policy number.  Depending on the settings in the
policy, the \acs{BMC} may go to the next alert policy or stop.

\begin{longtable}{|l|p{0.2\textwidth}|p{0.65\textwidth}|}
\caption{Alert Policy Table Entry\label{alert-policy-table-entry}}
\\ \hline
\bfseries{Byte} & \bfseries{Field} & \bfseries{Description}\\
\endhead
\hline
0 & Policy Number and Policy &
	\begin{description}
	\item[bits 0-2] - The policy.  Valid values are:
	  \begin{description}
	  \item[0h] - Alway do this alert if chosen, even if other
	    alert policy tables tell the \acs{BMC} to stop.
	  \item[1h] - If an alert to a previous destination was successful,
	    do not do this alert.  If no alert has been successful so far,
	    do this alert.  Then go to the next entry in the policy table.
	  \item[2h] - If an alert to a previous destination was successful,
	    do not do this alert.  If no alert has been successful so far,
	    do this alert.  Then stop processing the policy table (except
	    for entries with a 0h policy).
	  \item[3h] - If an alert to a previous destination was successful,
	    do not do this alert.  If no alert has been successful so far,
	    do this alert.  Then proceed to the next policy entry that
	    has a different channel.
	  \item[4h] - If an alert to a previous destination was successful,
	    do not do this alert.  If no alert has been successful so far,
	    do this alert.  Then proceed to the next policy entry that
	    has a different destination type.
	  \end{description}
	\item[bit 3] - Entry enable.  If set to one, the entry is enabled,
	  if set to zero it is ignored.
	\item[bits 4-7] - The policy number, the array index of which
	  policy table entry to set.
	\end{description}\\
\hline
1 & Channel / Destination &
	\begin{description}
	\item[bits 0-3] - The destination selector.  For the chosen
	  channel, this is the specific destination in the channel
	  to use to send the alert.  See the \acs{LAN} Configuration Table
	  (table \ref{lan-conf-parms}) or the Serial Configuration Table
	  (table \ref{serial-conf-parms}) for information on what the
	  destination selectors can do.
	\item[bits 4-7] - The channel.  This tells the BMC which channel
	  to send the alert over.
	\end{description}\\
\hline
2 & Alert String Info &
	Some types of alerts need a string associated with them, this
	chooses the string.  The specific strings are stored in the \ac{PEF}
	configuration parameters 12 and 13 in table \ref{pef-conf-parms}.

	If bit 7 of this byte is one, then the string is dependent on
	the event filter number that was matched for this alert policy.
	Bits 0-6 of this byte are the alert string set.
	The event filter number and the alert string set are looked up in
	the table in parameter 12 of the \ac{PEF} configuration to choose the
	alert string to use.  See that parameter for more details on how
	this works.

	if bit 7 of this byte is zero, then the bits 0-6 of this field
	are the alert string selector.  The alert string selector is
	used as a direct index into the alert string table in parameter
	13 of the \ac{PEF} configuration.\\
\hline
\end{longtable}

\subsection{OpenIPMI and \acs{SNMP} Traps}

\subsubsection{Setting Up A System To Send Traps}

Setting up a system to send traps with OpenIPMI can be done two basic
ways.  The hard way is to set up each table individually.  This is
more work, but is very flexible.  The easy way just sets up for SNMP
traps but does all the work for you.

\paragraph{Setting Up the \acs{PEF} Table and \acs{LAN} Configuration Table}

For a system to send traps, you must set up the \acs{PEF} table as
described in section \label{sec-pef-conf-parms} and the \acs{LAN}
configuration table described in section \label{sec-lan-conf-parms}.
However, this is a lot of work.

\paragraph{Setting Up For Traps the Easy Way}

OpenIPMI provides a way to set up a simple SNMP trap send from a
\ac{BMC}.  The call has an unfortunately large number of parameters
because OpenIPMI cannot pick the various selectors and policy numbers
needed to set up for the trap, because you may be using them for other
things.  The function call is:

\begin{verbatim}
int ipmi_pet_create(ipmi_domain_t    *domain,
		    unsigned int     connection,
		    unsigned int     channel,
		    struct in_addr   ip_addr,
		    unsigned char    mac_addr[6],
		    unsigned int     eft_sel,
		    unsigned int     policy_num,
		    unsigned int     apt_sel,
		    unsigned int     lan_dest_sel,
		    ipmi_pet_done_cb done,
		    void             *cb_data,
		    ipmi_pet_t       **pet);
\end{verbatim}

\begin{description}
\item[domain] - The domain to set up a trap sender for.
\item[connection] - Which specific connection to the domain do you
  want to configure?
\item[channel] -  The specific channel to configure.  You will have
  to know the channel you want to configure.
\item[ip\_addr] - The IP address to tell the \ac{BMC} to send messages to.
\item[mac\_addr] - The MAC address to tell the \ac{BMC} to send messages to.
\item[eft\_sel] - the Event Filter selector to use for this PET destination.
  Note that this does *not* need to be unique for different OpenIPMI
  instances that are using the same channel, since the configuration
  will be exactly the same for all EFT entries using the same
  channel, assuming they share the same policy number.
\item[policy\_num] - The policy number to use for the alert policy.  This
  should be the same for all users of a domain.
\item[apt\_sel] - The Alert Policy selector to use for this PET destination.
  Note that as \verb=eft_sel=, this need not be unique for each different
  OpenIPMI instance on the same channel.
\item[lan\_dest\_sel] - The LAN configuration destination selector for
  this PET destination.  Unlike \verb=eft_sel= and \verb=apt_sel=,
  this *must* be unique for each OpenIPMI instance on the same
  channel, as it specifies the destination address to use.
\item[done] - This function will be called when the PET configuration is
  complete.
\item[cb\_data] - Data to pass to the \verb=done= call.
\item[pet] - The created object.
\end{description}

This creates an object that will continue to live and periodically
check that the configuration is correct.  If you wish to destroy this,
use the following:

\begin{verbatim}
int ipmi_pet_destroy(ipmi_pet_t       *pet,
		     ipmi_pet_done_cb done,
		     void             *cb_data);
\end{verbatim}

\subsubsection{Handling Incoming Traps}

OpenIPMI has some ability to handle \acs{SNMP} traps.  It does not
implement its own \acs{SNMP} stack though, so it cannot do all the
work for you.  Indeed, different \acs{SNMP} exist and OpenIPMI would
not want to presume that you would only use one of them.  Also, since
the \acs{SNMP} trap port is fixed, some cooperative mechanism may be
required between different pieces of software. You must have your own
stack, like NetSNMP\cite{netsnmp}, and catch the traps with that.

Once you have a trap, you must call:

\begin{verbatim}
int ipmi_handle_snmp_trap_data(void            *src_addr,
			       unsigned int    src_addr_len,
			       int             src_addr_type,
			       long            specific,
			       unsigned char   *data,
			       unsigned int    data_len);
\end{verbatim}

Where \verb=src_addr= is the \acs{IP} source address
(\verb=struct sockaddr_in=) and length is the length of the address
structure.  Only \acs{IP} is supported for now, so
\verb=src_addr_type= must be \verb=IPMI_EXTERN_ADDR_IP=.  The
\verb=specific= field is the field of the same name from the
\acs{SNMP} \ac{PDU}.  The \verb=data= field is a pointer to the user
data from the \acs{SNMP} \ac{PDU}, and the length of that data is in
\verb=data_len=.

The data in the trap is not enough information to fully decode the
event, so currently an incoming trap will only cause an SEL fetch on
the proper \acs{SEL}.
OpenIPMI will automatically send the \acs{PET} Acknowledge command
described in Table \ref{pet-ack-cmd}.

Note that \acs{SNMP} traps can only be recieved on one port, and that
port is privileged, so you must run as root to receive SNMP traps.

\subsection{The Alert Immediate Command}
\label{sec-alert-immediate}

\section{OpenIPMI Addressing}
\label{openipmi-addressing}

The OpenIPMI driver and library use a common addressing scheme.  This
attempts to normalize the messaging from the user's point of view.
The message data will look the same no matter where you send it.  The
only difference is the message.

The main OpenIPMI address structure is:

\begin{verbatim}
struct ipmi_addr
{
	int   addr_type;
	short channel;
	char  data[IPMI_MAX_ADDR_SIZE];
};
\end{verbatim}

The \verb=addr_type= and \verb=channel= are common to all OpenIPMI
addresses.  You have to look at the \verb=addr_type= to determine the
type of address being used and cast it to the proper address.

A system interface address is used to route the message to the local
management controller.  It is:

\begin{verbatim}
#define IPMI_SYSTEM_INTERFACE_ADDR_TYPE	...
struct ipmi_system_interface_addr
{
	int           addr_type;
	short         channel;
	unsigned char lun;
};
\end{verbatim}

The channel should be \verb=IPMI_BMC_CHANNEL= and the lun should
generally be zero.

An \acs{IPMI} address routes messages on the \ac{IPMB}.  The format is:

\begin{verbatim}
#define IPMI_IPMB_ADDR_TYPE		...
#define IPMI_IPMB_BROADCAST_ADDR_TYPE	...
struct ipmi_ipmb_addr
{
	int           addr_type;
	short         channel;
	unsigned char slave_addr;
	unsigned char lun;
};
\end{verbatim}

The \verb=channel= should be the \ac{IPMB} bus channel number, the
\verb=slave_address= should be the \ac{IPMB} address of the destination,
and the \verb=lun= should be the destination \ac{LUN}.  Notice that two
address types can be used with this command, a normal \ac{IPMB} message and
a broadcast \ac{IPMB} can be sent with this.  Note that if you send a
broadcast \ac{IPMB}, you will receive a normal \ac{IPMB} address in the
response.

%---------------------------------------------------------------------
\chapter{\acs{IPMI} Commands}
\label{ipmi-commands}

\ac{IPMI} does everything except events through commands and
responses.  A user sends a command to an \ac{MC}, and the \ac{MC}
returns a response.  All commands have responses.  Commands may
optionally have some data; the data depends on the command.  The same
goes for responses, except that all responses contain at least on data
byte holding the completion code.  Every response has a completion
code in the first byte.

Every command and response has a \ac{NetFN} and command number.  A
\ac{NetFN} is a number that describes a function group.  All
sensor-related commands, for instance, have the same \ac{NetFN}.  The
command number is the number for the specific command within the
\ac{NetFN}.  Responses contain the same \ac{NetFN} and command number
as the command, except the \ac{NetFN} has one added to it.  So
responses to sensor command (\ac{NetFN} 04h) will use NetFN 05h.
Table \ref{netfn-codes} shows the \ac{NetFN} values.  All commands
have even \ac{NetFN}s, and all responses have odd \ac{NetFN}s.

\begin{longtable}{|l|p{0.8\textwidth}
\caption{\acs{NetFN} codes\label{netfn-codes}}
\\ \hline
\bfseries{NetFN} & \bfseries{Description}\\
\hline
\end{longtable}

\section{Sending Commands in OpenIPMI}

%---------------------------------------------------------------------
\chapter{\acs{SDR} Repositories}

%---------------------------------------------------------------------
\chapter{Entities}

\section{\acs{FRU} Data}

%---------------------------------------------------------------------
\chapter{Sensors}

  \acs{IPMI} defines
special types of sensors called Presence Sensors, these report if an
entity is present in the system.

Sensors provide a lot of functions depending on their type.  Threshold
sensors monitor ``analog'' things like temperature, voltage, or fan speed.
Discrete sensors monitor events or states, like the previously
introduced presence sensor, software initialization progress, or if
external power is present to the system.

Threshold sensors report their readings in values from 0-255.
OpenIPMI makes every effort to convert this to a floating-point value
for you to use.  \acs{IPMI} defines standard ways to convert values
using various formulas.  OpenIPMI implements all these and provides
ways for \acs{OEM} functions to plug in to provide their own
converters.  If you have a sensor that cannot be represented using the
standard mechanisms, you need to get the \acs{OEM} algorithms for this
and implement them in an \acs{OEM} plug-in for the sensors.

You may enable events on a threshold sensor by specifying values (called
thresholds) where you want the sensor to report an event.  Then you can
enable the events for the specific thresholds.  Not all sensors support
all thresholds, some cannot have their events enabled and others cannot
have them disabled.  The capabilities of a sensor may all be queried
by the user to determine what it can do.

Threshold sensors may have hysteresis, meaning that when the threshold
goes on above or below the specified value, the transition point where
the threshold goes off is somewhat below or above the given value.  For
instance, if you want a fan speed sensor to go off when it goes below
150 RPM, if the fan is hanging right around 150 RPM, the sensor may be
constantly sending you events as it goes slightly above and slightly
below 150 RPM, which is bad because it can overload the system
management software.  The hysteresis for the fan might be set at 10 rpm,
which means that if the speed goes below 150 RPM, then it must go above
160 RPM for the threshold to be disabled.  Hysteresis may be settable or
may be fixed for the sensor.

Discrete sensors report their readings in a 16-bit bitmask, each bit
representing a dicrete value.  You enable events on the sensor by
specifying which discrete values you want to generate events.  Like
threshold sensors, these events may or may not be user-controllable.
That information may be fetched by the user.

\begin{longtable}{|p{0.2\textwidth}|l|p{0.65\textwidth}|}
\caption{Sensor Types and Codes\label{sensor-type-codes}}
\\ \hline
\bfseries{Parameter} & \bfseries{\#} & \bfseries{Description}\\
\endhead
\hline
\end{longtable}

%---------------------------------------------------------------------
\chapter{Controls and Miscellany}

\section{Watchdog Timer}

\section{Chassis}

\section{Direct \acs{I$^2$C} Access}

%---------------------------------------------------------------------
\chapter{Hot Swap}

%---------------------------------------------------------------------
\chapter{Events}
\label{events}

\section{Event Format}
\label{event-format}

%---------------------------------------------------------------------
\appendix

\chapter{Comparison with \acs{SNMP}}

\chapter{Comparison with \acs{HPI}}

%---------------------------------------------------------------------
\chapter{ATCA}

%---------------------------------------------------------------------
\chapter{Motorola MXP}

%---------------------------------------------------------------------
\chapter{Command Receiver Program}
\label{recv-cmd-prog}
\verbatimtabinput{recv_cmd.c}

%---------------------------------------------------------------------
\chapter{Connection Handling Interface (ipmi\_conn.h)}
\label{ipmi-conn-h}
\verbatimtabinput{../include/OpenIPMI/ipmi_conn.h}

%---------------------------------------------------------------------
\chapter{OS Handler Interface (os\_handler.h)}
\label{os-handler-h}
\verbatimtabinput{../include/OpenIPMI/os_handler.h}

\bibliographystyle{plain}
\bibliography{ipmi}
\backmatter
\end{document}
