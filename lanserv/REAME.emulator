The lanserv_emu program is an IPMI emulator.  Command-line parameters
are:

  -c <file> - Use the file as the LAN configuration file (see the ipmilan.8
       manual for details on this).

  -x <string> - Execute the given string at startup.

  -f <file> - Execute all the commands in the given file.

  -d - turn debugging on.


Once it is up, it acts as an IPMI LAN based system, emulating a lot of
commands (but not nearly the whole set yet).  However, it comes up
empty.  You have to execute commands, either at the command line or in
a command file, to add the various data you need.

The commands available are:

quit - stop the program.

sel_enable <mc> <max entries> <flags>
  Enable the SEL device on the given MC, with the given number of
  entries and the flags for the Get SEL Info command response.

sel_add <mc> <record type> <byte1> ... <byte13>
  Add the given event to the SEL of the given MC.  If the record type
  is less than 0xe0, then the first four data byte are ignore and a
  timestamp is put in that place.

main_sdr_add <mc> <byte 1> .... <byte n>
  Add the given SDR to the main SDR repository of the given MC.  Note
  that the first two bytes are ignored and replaced with the record
  number.  Note that it is your responsibility to get the length
  correct.

device_sdr_add <mc> <LUN> <byte 1> .... <byte n>
  Add the given SDR to the main SDR repository of the given MC under
  the given LUN.  Note that the first two bytes are ignored and
  replaced with the record number.  Note that it is your
  responsibility to get the length correct.

sensor_add <mc> <LUN> <sensor num> <sensor type> <event reading code>
  Add a sensor to the MC with the given LUN and sensor number.  The
  type and reading code are also set.

sensor_set_bit <LUN> <sensor num> <bit to set> <bit value> <generate event>
  Only for discrete sensors.  Set the given bit in the sensor to the
  given value.  If <generate event> is non-zero, then an event will be
  generated if the sensor is set up to generate events.

sensor_set_value <LUN> <sensor num> <value> <generate event>
  Only for threshold sensors.  Set the sensor to the given value.  If
  <generate event> is non-zero, send an event if the value change
  should cause one based on thresholds.

sensor_set_hysteresis <LUN> <sensor num> <support> <pos> <neg>
  Only for threshold sensors.  Set the hysteresis for the sensor.
  <support> is the standard values from the SDR, which are:
	0 - IPMI_HYSTERESIS_SUPPORT_NONE
	1 - IPMI_HYSTERESIS_SUPPORT_READABLE
	2 - IPMI_HYSTERESIS_SUPPORT_SETTABLE
	3 - IPMI_HYSTERESIS_SUPPORT_FIXED
  <pos> is the positive hysteresis value, and <neg> is the negative
  one.

sensor_set_threshold <LUN> <sensor num> <support> <enabled> <val0> .. <val5>
  Only for threshold sensors.  This sets the threshold support type,
  supported thresholds, and initial values.  <support> is the standard
  values from the SDR, which are:
	0 - IPMI_THRESHOLD_ACCESS_SUPPORT_NONE
	1 - IPMI_THRESHOLD_ACCESS_SUPPORT_READABLE
	2 - IPMI_THRESHOLD_ACCESS_SUPPORT_SETTABLE
	3 - IPMI_THRESHOLD_ACCESS_SUPPORT_FIXED
  <enabled> is a bitmask (rightmost bit is lowest value) of the
  thresholds that will be supported.  It must have 6 entries.
  Thresholds are:
	0 - lower non critical
	1 - lower critical
	2 - lower non recoverable
	3 - upper non critical
	4 - upper critical
	5 - upper non recoverable
  <valx> sets the initial value of the threshold.

sensor_set_event_support <LUN> <sensor num> <enable> <scanning> <support>
	<assertions supported> <deassertions supported>
	<assertions enabled> <deassertions enabled>
  Sets the event support for the sensors.  <support> is the standard
  values from the SDR, which are:
	0 - IPMI_EVENT_SUPPORT_PER_STATE
	1 - IPMI_EVENT_SUPPORT_ENTIRE_SENSOR
	2 - IPMI_EVENT_SUPPORT_GLOBAL_ENABLE
	3 - IPMI_EVENT_SUPPORT_NONE
  <enable> and <scanning> are the initial values of those bits for the
  sensor.  The supported fields set what bits are supported.  The
  enabled fields set what events are initially enabled.  These are
  bitmasks with the lowest number as the rightmost bit.  They must
  have 15 values.

  For threshold sensors, the bit values are:
	0  - lower non-critical going low
	1  - lower non-critical going high
	2  - lower critical going low
	3  - lower critical going high
	4  - lower non-recoverable going low
	5  - lower non-recoverable going high
	6  - upper non-critical going low
	7  - upper non-critical going high
	8  - upper critical going low
	9  - upper critical going high
	10 - upper non-recoverable going low
	11 - upper non-recoverable going high
  Note that the "lower going high" and "upper going low" values are
  not supported, since they are simply stupid.  You must still supply
  15 values, even though the top 3 are not used.

mc_set_power <mc> <power> <generate event>
  Set the power value for the MC.  Note that this just sets a value in
  the sensor and optionally generates an event.  The event is in the
  format:
       bytes    description
	0-1	record id
	2	record type (0xc0)
	3-6	timestamp
	7	IPMB of event generator (always 0x20)
	8	
	9	version (always 1)
	10	
	11	IPMB of device being powered.
	12	
	13	power level set
	14
	15

mc_add_fru_data <mc> <length> <device id> <data 1> .. <data n>
  Set the FRU data for the given MC/device id to be <length> bytes
  long and initialize the data to the given values.  Note that the
  initial data need not be as long as the full length of the FRU
  data.

mc_add <IPMB> <dev id> <has device SDRs> <device revision>
	<major FW rev> <minor FW rev> <device support>
	<manufacturer id> <product id> <dynamic sensor population>
  Create a new management controller at the given IPMB with the given
  parameters.

mc_setbmc <mc>
  Set the given MC to the "bmc" device.  This should generally be MC
  0x20.

read_cmds <file>
  Read and execute the commands from the given file.
