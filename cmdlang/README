This is the OpenIPMI command language, which allows each access to
pretty much everything about OpenIPMI.  It can be used to add an
OpenIPMI command shell into an application to give the user full
access into everything OpenIPMI can do.

The interface is very simple.  You call the command interpreter with a
string.  You pass in two functions, an output handler and a "done"
functions.  If an error occurs, the command interpreter generates some
output and returns an error code.  Otherwise, it will generate output
and call the done function when it is complete.

The command language is hierarchical.  There are several top-level
commands, each of these has sub-commands, and those may have
sub-commands, and so on.

The commands may take parameters.  Some general ones are:

* <domain> - A name of a domain.  Each registered domain in a system
  has a name.
* <entity> - Entity names are in the form: [<domain>[(entity spec)]]
  Notice that the entity spec is optional.  If it is not listed, then
  the operation is done on all entities in the domain.  The whole
  thing is optional, too, if nothing is given then the operation is
  done on every entity in every domain.
  The entity spec is either:
   <entity id>.<entity instance>
  for system-reltive entities, or:
   r<channel>.<IPMB>.<entity id>.<entity instance-0x60>
  for device-relative entities.
* <sensor> - These come in the form [<entity>[.name]] If no name is
  given, the operation is performed on all sensors in the entity.
  If the entity is just a domain, then all sensors in the domain, and
  if the whole thing is empty, then all sensors on all domains.
* <control> - These come in the form [<entity>[.name]] If no name is
  given, the operation is performed on all controls in the entity.
  If the entity is just a domain, then all controls in the domain, and
  if the whole thing is empty, then all controls on all domains.
* <mc> - A management controller.  These come in the form
  [<domain>[(<channel>.<IPMB>)]].  As usual, the optional parts will
  cause defaulting to all things.
* <connection> - A connection number, in the form: <domain>.<num>

Note that the domain name and sensor/control name may have spaces in
them; the names may be bracketed by quotes (' or ").  A backslash (\)
may be used to add a quote character (or a backslash) into a string.
An empty parameters should be specified as "", although if nothing
comes after the parameter it may just be left empty.

The command hierarchy is:

* help - get general help.
* domain
  * help
  * list - List all domains
  * info <domain> - List information about the given domain
  * fru <is_logical> <device_address> <device_id> <lun> <private_bus>
    <channel> - dump a fru given all it's insundry information.
  * msg <mc> <LUN> <NetFN> <Cmd> [data...] - Send a command
    to the given IPMB address on the given channel and display the
    response.  Note that this does not require the existance of an
    MC.
  * pet <connection> <channel> <ip addr> <mac_addr> <eft selector>
    <policy num> <apt selector> <lan dest selector> - 
    Set up the domain to send PET traps from the given connection
    to the given IP/MAC address over the given channel
  * scan <ipmb addr> [ipmb addr] - scan an IPMB to add or remove it.
    If a range is given, then scan all IPMBs in the range
  * presence - Check the presence of entities
  new <domain> <parms...> - Open a connection to a new domain
  close <domain> - close the given domain
* entity
  * help
  * list <domain> - List all entities.
  * info <entity> - List information about the given entity
  * hs - hot-swap control
    * get_act_time <entity> - Get the host-swap auto-activate time
    * set_act_time <entity> - Set the host-swap auto-activate time
    * get_deact_time <entity> - Get the host-swap auto-deactivate time
    * set_deact_time <entity> - Set the host-swap auto-deactivate time
    * activation_request <entity> Act like a user requested an
      activation of the entity.  This is generally equivalent to
      closing the handle latch or something like that.
    * activate <entity> - activate the given entity
    * deactivate <entity> - deactivate the given entity
    * state <entity> - Return the current hot-swap state of the given entity
    * check <domain> - Audit all the entity hot-swap states
  * fru <entity> - Dump the FRU information about the given entity.
* sensor
  * help
  * list <entity> - List all sensors
  * info <sensor> 
  * rearm <sensor> - rearm the current sensor
  * set_hysteresis - Sets the hysteresis for the current sensor
  * get_hysteresis - Gets the hysteresis for the current sensor
  * events_enable <events> <scanning> <assertion bitmask> <deassertion bitmask>
    - set the events enable data for the sensor
* control
  * help
  * list <entity> - List all controls
  * info <control> 
  * set <control> <val1> [<val2> ...] - set the value(s) for the control
* mc
  * help
  * list <domain> - List all MCs
  * info <mc> 
  * reset <warm | cold> <mc> - Do a warm or cold reset on the given MC
  * cmd <mc> <LUN> <NetFN> <Cmd> [data...] - Send the given command"
    to the management controller and display the response.
  * set_events_enable <enable | disable> <mc> - enables or disables
    events on the MC.
  * get_events_enabled <mc> - Prints out if the events are enabled for
    the given MC.
  * sdrs <main | sensor> <mc> - list the SDRs for the mc.  Either gets
    the main SDR repository or the sensor SDR repository.
  * get_sel_time <mc> - Get the time in the SEL for the given MC
* pef
  * read <mc> - read pef information from an MC.  Note the lock is not
    released.
  * clearlock <mc> - Clear a PEF lock.
  * write <mc> <pefval> <value> [pefval <value> [...]]
    - write the PEF information to the MC.  Every value given will be
     written atomically and the lock will be released.  Note that
     you must do a read before doing this command.
* lan
    * read <mc> <channel> - read lanparm information from an MC for
      the given channel on the MC.  Note the lock will not be released
      after this command.
    * clearlock <mc> <channel> - Clear the LAN parm lock on the given
      MC and channel.
    * writelanparm <mc> <channel> <lanval> <value> [lanval <value> [...]]
      - write the LANPARM information to an MC.  Every value given will be
      written atomically and the lock will be released.  Note that
      you must do a read before doing this command.
* con
  * active <connection> - print out if the given connection is active or not
  * activate <connection> - Activate the given connection
* sel
    * delevent <mc> <log #> - Delete the given event number from the SEL
    * addevent <mc> <record id> <type> <13 bytes of data> - Add the
      event data to the SEL.
    * clear <domain> - clear the system event log
    * list <domain> - list the local copy of the system event log
* general
  * debug <type> on|off - Turn the given debugging type on or off
  * xml on|off - enable or disable XML-style output

Note that everything comes back in name/value pairs and can be sent
back in XML format.  If a command begins with "<", and xml is on,
everything after is assumed to be valid XML until the end of the
XML sequence.
