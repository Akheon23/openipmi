\input texinfo   @c -*-texinfo-*-
@setfilename OpenIPMI.info
@settitle OpenIPMI Interface Users's Guide
@setchapternewpage odd

@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{OpenIPMI User's Guide}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002 MontaVista Software
@end titlepage

@node    Top,       Intro to IPMI,         , (dir)

This document describes OpenIPMI, and IPMI abstraction layer that makes
IPMI easier to use, and allows OEM vendors to supply plugins to support
their special sensors and controls.

@menu
* Intro to IPMI::     A little about IPMI
* Concept Index::     
* OpenIPMI Concepts::
* Using OpenIPMI::
* OpenIPMI Internal Interfaces::
* How to Write OEM Plugins::
* Internals::
* Glossary::
@end menu

@node    Intro to IPMI, OpenIPMI Concepts, Top,      Top
@comment node-name,     next,          previous, up
@chapter Intro to IPMI
@cindex intro

If you have read the IPMI spec, you are probably thoroughly confused
about IPMI.  The IPMI spec doesn't provide the high-level expected usage
of IPMI.  This chapter covers that information.  It provides a
high-level view of how IPMI is expected to be used.

@menu
* Things in IPMI::
* The User View::
@end menu

@node    Things in IPMI, The User View, Intro to IPMI, Intro to IPMI
@section Things in IPMI

IPMI is a specification for system monitoring.  It monitors entities in
your system with sensors.  Sensors can generate events, which may be
stored in a System Event Log (SEL) and forwarded to listening parties.
Information about the system may be stored in Sensor Data Records
(SDRs), which hold information about a whole lot more things than
sensors.  Various Management Controllers (MCs) may exist in the system,
these are the intelligent devices that control the sensors in the
system.  The main MC is the Baseboard Management Controller (BMC), it is
what what the external software interacts with directly, either through
a system interface, a LAN connection, a serial connection, etc.

Note that a sensor may be something you don't traditionally think of as
a sensor.  Beyond standard analog sensors, there are sensors for the
presence of entities, sensors from buttons, sensors for predictive
values, and a host of other things.  An MC may generate events as the
BIOS on the board it's on goes through it's processing.  In general, a
sensor may be attached to anything that can be sensed or monitored.

Inside the system, the various devices generally communicate over an
Intelligent Peripheral Management Bus (IPMB).  So if you need to message
a specific sensor, you will send a message to the BMC asking it to
forward the message to the proper MC over the IPMB bus.  The destination
is specified via an IPMB address.

IPMB addresses contain a slave address, which identifies the MC.  They also
contain a Logical Unit Number (LUN), which identifies an entity inside
the MC.

Some types of connections need to be authenticated, you will need to
provide userids and passwords for the BMC to accept your messages.
Several different authentication algorithms are available.

@node    The User View, , Things in IPMI, Intro to IPMI
@section The User View

A bunch of acronyms have just been introduced, along with a lot of vague
concepts.  The nice thing is that the user of OpenIPMI doesn't really
have to know about all these things.  From the user's point of view, the
entity provides the central framework for everything else.  Sensors
monitor entities.  Entities may be present or absent.  When you connect
to a BMC, OpenIPMI takes care of detecting the entities in the system
and reporting them to you.  You may register with the BMC to be told
when entities are added or removed from the database.  Note that an
entity may be present in the database, but not present in the system,
the reporting from the BMC only gives the presence in the database, not
physical presence in the system.

You may register with an entity to be told when it's physical presence
in the system changes.  Some devices (like power supplies) are
field-replacable while the system is running, these are called Field
Replacable Units (FRUs).

Sensors are also automatically detected and reported.  This is done
through entities, you register with an entity to be told when a sensor
has been added or removed.  IPMI defines special types of sensors called
Presence Sensors, these report if an entity is present in the system.  A
presence sensor is @emph{not} reported to the user, OpenIPMI attaches
these to the entity directly and uses them to detect the presence of the
entity.

Sensors provide a lot of functions depending on their type.  Threshold
sensors monitor "analog" things like temperature, voltage, or fan speed.
Discrete sensors monitor events or states, like the previously
introduced presence sensor, software initialization progress, or if
external power is present to the system.

Threshold sensors report their readings in values from 0-255.  OpenIPMI
makes every effort to convert this to a floating-point value for you to
use.  IPMI defines standard ways to convert values using various
formulas.  OpenIPMI implements all these and provides ways for OEM
functions to plug in to provide their own converters.  If you have a
sensor that cannot be represented using the standard mechanisms, you
need to get the OEM algorithms for this and implement them in an OEM
plug-in for the sensors.

You may enable events on a threshold sensor by specifying values (called
thresholds) where you want the sensor to report an event.  Then you can
enable the events for the specific thresholds.  Not all sensors support
all thresholds, some cannot have their events enabled and others cannot
have them disabled.  The capabilities of a sensor may all be fetched
by the user to determine what it can do.

Threshold sensors may have hysteresis, meaning that when the sensor goes on
above or below the specified value, the transition point where the
threshold goes off is somewhat below or above the given value.  For
instance, if you want a fan speed sensor to go off when it goes below
150 RPM, if the fan is hanging right around 150 RPM, the sensor may be
constantly sending you events as it goes slightly above and slightly
below 150 RPM, which is bad because it can overload the system
management software.  The hysteresis for the fan might be set at 10 rpm,
which means that if the speed goes below 150 RPM, then it must go above
160 RPM for the threshold to be disabled.  Hysteresis may be settable or
may be fixed for the sensor.

Discrete sensors report their readings in a 16-bit bitmask, each bit
representing a dicrete value.  You enable events on the sensor by
specifying which discrete values you want to generate events.  Like
threshold sensors, these events may or may not be user-controllable.
That information may be fetched by the user.

@c **********************************************************************
@node    OpenIPMI Concepts, Using OpenIPMI,  Intro to IPMI, Top
@chapter OpenIPMI Concepts

OpenIPMI is an event-driven library that is designed to be relatively
operating system independent.  If you have written control systems or
things like that in the past, you will be quite familiar with
event-driven systems and may skip to the next section.  If not, you want
to read this.  Event-driven systems may seem a little unusual, but they
are accepted practice and by far the best way to build control systems.

@menu
* Event-Driven Systems::
* The OS Handler::
* Messaging Interfaces::
* Error Handling::
* Locking::
* OpenIPMI Objects::
@end menu

@node    Event-Driven Systems, The OS Handler, OpenIPMI Concepts, OpenIPMI Concepts
@section Event-Driven Systems

In an event-driven system, you never stop and wait for something to
happen.  If you are not used to this, you are probably used to writing
code like this:
@example
  while (true) @{
    wait_for_input();
    perform_op1();
    wait_for_op1_results();
    perform_op2();
  @}
@end example
This is fairly straightforward, but it has some problems.  What if
another more important input comes in while you are waiting for the
results of @code{perform_op1()}?  Now @code{wait_for_op1_results()} will
have to handle input, too, and somehow return and say something is
happening.  The loop will then have to somehow handle multiple
operations in progress.  And this is a simple example, what if there
were hundreds of possible inputs, each with their own result handler,
and each had to go through several states?  You could assign each to a
thread, but if you have thousands of possible pending operations in a
system, that many threads may thrash your system and render it
inoperable, probably right at the time you need it most (since a lot of
things are going on).

In an event-driven system, instead you would say:
@example
  init()
  @{
    <initialize input_data>
    register_for_input(op1_handler, input_data);
  @}
  op1_handler(input_data)
  @{
    <allocate and initialize op_data>
    perform_op1(..., op2_handler, op_data);
  @}
  op2_handler(op_data)
  @{
    perform_op2();
    <free op_data>
  @}
@end example
As you see, when you start an operation, you provide the next thing to
call when the operation completes.  The functions passed around are
called ``callbacks''.  You allocate and pass around chunks
of data to be passed to the handlers.  And you register input handler
that get called when certain event occur.  So the code runs in short
non-blocking sections, registers for the next operation, then returns
back to some invisible main loop that handles the details of scheduling
operations.  This may seem more complicated than the previous example,
but it has a large number of advantages:
@enumerate
@item The system is almost always ready to handle input.  For instance,
user-interface systems (like most widget sets) are almost always
event-driven, this
makes them much more ``live'', since they are always ready to handle
user input.
@item This system can handle multiple operations simultaneously without
threads.  In general, threaded systems are less reliable and more
complicated, unless you need priorities or scalability on SMP, why use
them?  And even if you use them, you can have much better control over
what is running in the system.
@item If you are building a redundant system with data replication, this
gives you a natural way to hold your data, know when to transfer it over
to the mate system, and continue an operation on the mate system.
@item If you track the data, it's easy to monitor every operation
occuring in the system, stop an operations, or whatever.
@end enumerate

In general, a threaded system is easier to conceptually understand until
you understand event-driven methods.  An event-driven system is almost
always easier to correctly implement.

This is often called ``state-machine programming'' since most control
systems are state-machine based, and this is a natural way to implement
a state machine.  The @code{op_data} holds the state of the state
machine, each input gets @code{op_data}, looks at the current state, and
decides what to do next.

The OpenIPMI library is completely event-driven.  It has no internal
blocking operations, and it expects that anything it calls will not
block.  IPMI messaging and operating system primitives are provided
through external plug-in pieces.

If a library function that takes a callback does not return an error,
the callback is guaranteed to be called, even if the object the call is
associated with goes away.  If it goes away, a NULL may be passed to the
callback, but the @code{cb_data} will still be valid.

@node    The OS Handler, Messaging Interfaces, Event-Driven Systems, OpenIPMI Concepts
@section The OS Handler

The OS handler provides services for the OpenIPMI library.  These
services are:
@table @samp
@item Input Callbacks
The OpenIPMI code uses the ``file descriptor'' concept of *nix, input
devices are numbered.  This is not used internally in the library, but
it is used by the messaging interfaces, so the messaging interfaces and
OS handler may implement their own conventions for these numbers.  But
this provides a way to register to receive input from devices.

@item Timers
OpenIPMI times everthing (as it should), thus it needs timers.

@item Locks
OpenIPMI does not require locks, you may leave the operations NULL and
they won't be used.  However, if you are doing multi-threaded
operations, you should provide locks.  The locks should be recursive
(the same lock may be claimed multiple times by the same thread).  You
need to provide read/write locks operations, although these may be
normal locks (the system will just be less responsive).

@item Condition Variables
These are condition variables like the ones specified in POSIX threads.
Although OpenIPMI does not use condition variables (since it never waits
for anything) it may be convenient for other things to have them.
OpenIPMI does not use them, and if nothing in your system needs them,
they need not be provides.

@item Random Data
For certain operations, OpenIPMI needs random data.
@end table

@node    Messaging Interfaces, Error Handling, The OS Handler, OpenIPMI Concepts
@section Messaging Interfaces

Messaging interfaces provide the low-level interface to the BMC.  It can
be through a LAN, a system interface, a serial port, or a host of other
possible interfaces.

@node    Error Handling, Locking, Messaging Interfaces, OpenIPMI Concepts
@section Error Handling

Almost all OpenIPMI calls that do anything besides fetch a piece of
local data will return an integer error value.  A zero means no error.
Two types of errors are returned, system errors (which are standard Unix
errno values) and IPMI errors (which are the standard IPMI error codes).
You can use the macros @var{IPMI_IS_OS_ERR} and
@var{IPMI_IS_IPMI_ERR} to tell the type of error, and
@var{IPMI_GET_OS_ERR} and @var{IPMI_GET_IPMI_ERR} to get
the actual error values.

Note that if your system doesn't have Unix-type error numbers, you will
have to provide those for the OpenIPMI library.

If a function returns an error, any callbacks provided to that function
will NEVER be called.  Errors are passed into many callbacks, if an
error is present the rest of the data in the callback is probably not
valid except for the @code{cb_data} variable you provide, and possibly
the object the callback is associated with.  The object the callback is
associated with may be NULL if it has ceased to exist.

@node    Locking, OpenIPMI Objects, Error Handling, OpenIPMI Concepts
@section Locking

As mentioned before, you may or may not be using locking, @strong{but
you must read this section anyway.}  Locking here involves existance of
entities as well as normal locking.

The basic principle of locking is that if you are in a callback for an
IPMI object (an IPMI object is passed in the callback), that object is
locked and the system cannot change it.  In any callback for an object
owned by a particular BMC, that object will be locked and anything it
belongs to will be locked.  So, for instance, in a callback for a
sensor, the sensor is locked, the entity the sensor belongs to is
locked, and the management controller the sensor is on is also locked.
No other sensors, entities, or management controllers will necessarily
be locked.  Outside of callbacks, the library is free to change
pointers, change information, add and remove objects, or whatever it
wants.

So how do you obtain a lock for an IPMI object?  If you are handling
incoming IPMI events you generally don't have to worry about this.  But
say you are handling outside input, such as a user interface.  What
then?  If the pointers can change, how do I keep a reference to
something?

OpenIPMI provides two identifiers for IPMI objects.  One is a pointer,
but a pointer is only good inside a callback.  The other is an OpenIPMI
id, the id is good outside callbacks.  But the only thing you can do with
an id is pass it to a function that will call a callback for you with
the pointer.  You can convert a pointer to an id (inside a callback, of
course) so you should do that if you need to save a reference to the
object.

This mechanism, though a little inconvenient, almost guarantees that you
will not forget to release a lock.  It nicely encapsulates the locked
operation in a function@footnote{This is how locking works in Ada95 and
Java, although their mechanisms are a little more convenient since they
are built into the language}.  You have to return from the function
unless you exit, longjmp, or throw an exception that falls through the
callback, and you shouldn't do those things.

You must do this whether you are using locking or not, because the
library uses this mechanism to determine whether the id you are holding
is good.  Once it converts the id to the pointer, your pointer is
guaranteed to be good until the function returns.

@node    OpenIPMI Objects, , Locking, OpenIPMI Concepts
@section OpenIPMI Objects

In OpenIPMI, the user deals with four basic objects: the BMC, entities,
sensors, and control.

@subsection The BMC

The BMC is the representative for the system.  It's what perform the
connection to, and the entities in the system are attached to the BMC.
When you have successfully connected to a system, the BMC is given to
you in the callback.

@subsection Entities

Entities are things that are monitored.  They may be physical things
such as a power supply or processor, or more abstract things such as the
set of all power supplies or the ambient air in a chassis.  Sensors
monitor entities, and controls are attached to entities.

Entities may be grouped inside other entities, thus an entity may have a
parent (if it is grouped inside another entity) and children (if it
contains other entities).  These relationships are abstract; you may
change them if it you like.  A raw system with no SDR data will not have
any relationships defined.  Relationships are stored in the SDR
repository, you may change them and store them back, if you like and if
the system supports that.

@subsection Sensors

Sensor monitor something about an object.  IPMI defines many types of
sensors, but groups them into two main categories: Threshold and
discrete.  Threshold sensors are ``analog'', they have continuous (or
mostly continuous) readings.  Things like fans speed, voltage, or
temperature.

Discrete sensors have a set of binary readings that may each be
independently zero or one.  In some sensors, these may be independent.
For instance, a power supply may have both an external power failure
and a predictive failure at the same time.  In other, they may be
mutually exclusive, such as the initialization state of a piece of
software.

@subsection Controls

Controls are not part of the IPMI spec, but are necessary items in
almost all systems.  They are provided as part of OpenIPMI so that OEM
code has a consistent way to represent these, and so OpenIPMI is ready
when the IPMI team finally sees the light and adds controls.
OpenIPMI defines many types of control: lights, relays, displays,
alarms, reset, power, fan speed, and identifiers.

For all controls except displays and identifiers, the control may
actually control more than one device.  With some controls, multiple
device may be controlled together and individual ones cannot be set (ie,
the same message sets all of them).  For these types of controls,
OpenIPMI represents them as a single control with multiple devices.
All the devices are read and set at once.

Lights are on/off colored devices, like an LED.  They may be
multi-color, but can only show one color at a time.  For instance, if
you work for Kmart, or you are managing a CompactPCI system with
hot-swap, you will have a blue light in your system.  You can search
through the controls to find a light that's blue.  Then, if a special
is on, or you want the operator to remove a card, you can light the blue
light.  Lights may blink, too.  Each light can have settings.  Each
setting describes a sequence of one or more transitions the light may go
through.

Relays are binary outputs.  Most telephony systems have them; they are
required by telephony specs.  They are simple on/off devices.

Displays are two-dimensional arrays of characters.  OpenIPMI allows you
to change individual characters at will.

Alarms are bells, whistles, gongs, or anything to alert the user that
something is wrong.

Reset controls are used to reset the entity to which they are attached.

Power controls can be used to control power to or from an entity.  A
power control on a power supply would generally control output power.  A
power control on a board would generally control input power to the
board.

Fan speed controls can be used to set the speed of a fan.

Identifier controls hold identification information for a system, such
as a chassis id, chassis type, geographic address, or whatever.

@c **********************************************************************
@node    Using OpenIPMI, OpenIPMI Internal Interfaces, OpenIPMI Concepts, Top
@chapter Using OpenIPMI

This chapter discusses how to use the OpenIPMI library.  Note that not
all the details of everything are covered.  See the include files for
details on the functions and types.  This covers the concepts so you can
understand the include files.

@menu
* Include Files::
* Initialization::
* The BMC::
* Entities::
* Sensors::
* Controls::
* The System Event Log (SEL)::
@end menu

@node    Include Files, Initialization, Using OpenIPMI, Using OpenIPMI
@section Include Files

@subsection Files the normal user deals with

@table @samp
@item @file{ipmiif.h}
The main include file for OpenIPMI.  It contains the main functions the
user must deal with when working with the OpenIPMI library.  Almost
everything will include this.  It includes @file{ipmi_types.h} and
@file{ipmi_bits.h}, too, so you don't have to include those.

@item @file{ipmi_auth.h}
The file holding information about athentication algorithms.  You need
this if dealing with an authenticated interface.

@item @file{ipmi_bits.h}
Various values, mostly for sensors, used by the user.  @file{ipmiif.h}
includes this file, so you generally don't have to include it explicitly.

@item @file{ipmi_types.h}
Types for the basic IPMI objects.  @file{ipmiif.h} includes this file,
so you generally don't have to include it explicitly.

@item @file{ipmi_err.h}
Error values, both IPMI and system, as well as macros for interpreting
these.

@item @file{os_handler.h}
The os-specific handler types are defined here.  You must implement this
and supply it to the IPMI code.

@item @file{selector.h}
For *nix systems, This file a default mechanism for handling many of the
os-specific handler operations.

@subsection Files dealing with messaging interfaces

@item @file{ipmi_lan.h}
This is the LAN messaging interface, this contains the calls for
creating a LAN connection.

@item @file{ipmi_smi.h}
This is the messaging interface for talking to local IPMI interfaces
(like KCS), this contains the calls for creating an SMI connection.

@subsection Internal files that OEM code and messaging interfaces deal with

@item @file{ipmi_addr.h}
The file holding information about IPMI addresses.

@item @file{ipmi_conn.h}
This defines the interface for the messaging interfaces.

@item @file{ipmi_entity.h}
This defines internal entity interfaces.

@item @file{ipmi_control.h}
This defines internal control interfaces.

@item @file{ipmi_int.h}
This defines other miscellaneous internal interfaces.

@item @file{ipmi_mc.h}
This defines internal interfaces for the management controllers.

@item @file{ipmi_msgbits.h}
This defines various IPMI messages.

@item @file{ipmi_oem.h}
This defines interfaces that OEM code can tie into.

@item @file{ipmi_sel.h}
This defines the internal interfaces for the SEL.

@item @file{ipmi_sdr.h}
This defines internal interfaces for the sdr repostiory.

@item @file{ipmi_sensor.h}
This defines internal interfaces for sensors.

@end table

@node    Initialization, The BMC, Include Files, Using OpenIPMI
@section Initialization

To initialize the OpenIPMI library, you must call @var{ipmi_init} and
pass in an @var{os_handler_t} in to it.  OpenIPMI will use this OS
handler for global operations.  This @emph{must} be done before any
other OpenIPMI calls.

@node    The BMC, Entities, Initialization, Using OpenIPMI
@section The BMC

Once OpenIPMI has been initialized, you need to establish connections to
BMCs.  The connection-establishment call is different for each messaging
interface due to varying authentication and information requirements.
See the include file for the messaging interface for details.
They all take a @var{ipmi_setup_done_t} parameter that will be called
with the newly created connection when the connection has been
established.  You may make as many connections as you like (limited by
available memory and CPU, of course).

The callback gives you an MC type -- the BMC -- that is your main
messaging interface into the system.  The entities are also attached to
the BMC, you have mechanisms to iterate over the entities.

When the BMC is given to you, the OpenIPMI library is still scanning the
IPMB bus to find all the other MCs on the bus.  As it finds them, it
will scan the sensors on the MC and add them to entities and create new
entities as necessary.  So when OpenIPMI hands you the BMC, you probably
don't have everything in the chassis.  In fact, IPMI is dynamic, so you
have to be ready for changes as they happen.

OpenIPMI will rescan the bus for new MCs every 10 minutes.  It is
expected that OEM handlers can detect new MCs with custom events and add
the new MC sooner.

Events also come in on the BMC interface.  In the setup done callback,
you should register for events, if you are interested in them.  This
means that your callback will receive all events that are not attached
to a sensor.  If an event is attached to a sensor, it will be delivered
to a callback associated with the sensor.

@node    Entities, Sensors, The BMC, Using OpenIPMI
@section Entities

Entities are the things that sensors monitor and controls can change
things on.  When a BMC is reported to you, you should register a callback to
tell you when entities are added or removed.  That way you can know
about new entities as soon as they are created.  If you wait until later
to register the callback, entities may have come into existance and you
will miss them (although you could catch them in an iterator).

Sensors and controls hang off entities.  OpenIPMI provides iterators
so you can scan all the sensors and controls on an entity.  It allows
you to register callbacks to tell you when sensors and controls are
added to or removed from the entity.  You sould do this in the entity
creation callback so you won't miss any sensors or controls as they
are detected.

Entities are hierarchical in nature.  An entity can have children
entities.  OpenIPMI allows you to create these relationships in the
local database and push them to the SDR database on the chassis, if you
like.  The next time it starts, it will pull them from the SDR database
and recreate the relationships.  If you have multiple power supplies in
a subchassis, or multiple processors on a board, the entity
relationships let you create nice containment relationships.

And entity may be present or absent in the system.  If the entity is an
FRU, this is expected.  OpenIPMI will automatically detect presence or
absense of an entity and report this to you via a callback.  Like the
other callbacks, you should register them in the entity creation
callback.

@node    Sensors, Controls, Entities, Using OpenIPMI
@section Sensors

Sensors, of course, are what IPMI is mostly about.  A sensor monitors
a characteristic of an entity.  IPMI specifies two main classes of
entities: threshold and discrete, described individually later.

It is important to note that all operations on a sensor are serialized,
each sensor has a queue of operations to perform, and it will only
perform one operation at a time on a sensor.  This is important, some
operations may require multiple messages to complete, and if you
intermix them it could cause confusion.  It also makes management of the
sensor easier for the user.

@menu
* Threshold Sensors::
* Discrete Sensors::
* Sensor Events::
@end menu

@node    Threshold Sensors, Discrete Sensors, Sensors, Sensors
@subsection Threshold Sensors

Threshold sensors measure ``continuous'' data, data that generally
measure physical constants like voltage, temperature, etc.  IPMI calls
them ``threshold'' sensors because you can set thresholds for them.
Then a threshold is exceeded, some sensors can send an event to the BMC.

Threshold sensors, unfortunately, are exceedingly complicated.  They
have a large number of settings, many options for conversion between the
discrete values and real values, and may support many optional
settings.  OpenIPMI attempts to hide much of this complexity, but it can
only go so far.

IPMI threshold sensors have the following settings:
@table @samp
@item Scanning
The sensor can be turned on and off using the status field of
@var{ipmi_thresholds_t} by setting or clearing
@var{IPMI_SENSOR_SCANNING_ENABLED} in the bitmask.  You have to use
@var{ipmi_sensor_get_sensor_init_scanning} function to tell if you
need to turn scanning on or off.

@item Events
Some sensors can generate events, some can't.  For more details, see
@xref{Sensor Events}.

@item Thresholds
Some sensors support thresholds.  See below for more details.

@item Hysteresis
Some sensors have hysteresis values.  The function
@var{ipmi_sensor_get_sensor_init_events} will tell you if you need to
initialize the hysteresis value for the sensor.  The
@var{ipmi_sensor_get_hysteresis support} tells you what type of
hysteresis (if any) the sensor supports.  

@end table

IPMI specifies the following thresholds:
@table @samp
@item non-recoverable
@item critical
@item non-critical
@end table

Their meanings are not really defined by IPMI, but they should be
obvious.  Each of these can have an upper and lower type, so for
instance you can have a critical upper and critical lower voltage
threshold.  As well, each of these may support an assertion and
deassertion event (an event when the value goes beyond the given range,
and another event when the value goes back within the given range, with
possible hysteresis).

In addition, the sensor may detect going above the given threshold (a
high-going threshold) or below the given threshold (a low-going
threshold).  This may seem redundant with the upper and lower
thresholds, but that's what the spec says.

Of course, few sensors support all these possible values, and you must
be able to tell what they support.  You use the
@var{ipmi_sensor_threshold_assertion_event_supported} and
@var{ipmi_sensor_threshold_deassertion_event_supported} functions to
tell if the sensor supports a given threshold event.  The thresholds may
or may not be readable and settable, use the
@var{ipmi_sensor_threshold_settable} and
@var{ipmi_sensor_threshold_readable} to tell if a threshold can be set
or read.

To turn on and off thresholds and support for events and to set the
thresholds, you must first fill out an @var{ipmi_event_state_t}
structure using the various calls defined to do this.  Then call
@var{ipmi_sensor_events_enable_set} to set the values.  The current
values may be fetched with @var{ipmi_sensor_events_enable_get}.

@node    Discrete Sensors, Sensor Events, Threshold Sensors, Sensors
@subsection Discrete Sensors

IPMI represents discrete sensors as a bitmask, each bit representing a
possible discrete state.  One bit is reserved for other use.  This
limits you to 15 possible states for each sensor, but that's generally
not a big deal

The meanings of the readings are specified one of two ways.  This is
specified by the @var{ipmi_sensor_get_event_reading_type}.  A value of
one means a threshold sensor.  A value of 0x6f means the reading depends
on the sensor type.  Values 0x2-0xc are generic readings that can apply
no matter what the sensor type, and are specified in the IPMI spec.

When the reading depends on the sensor type, you must do an
@var{ipmi_sensor_get_sensor_type} to retrieve the sensor type.  You can
use this to tell what the reading means.

@node    Sensor Events, , Discrete Sensors, Sensors
@subsection Sensor Events

Both threshold and discrete sensors support events, and they work about
the same for both, if you think of a threshold as a discrete state.
Individual discrete states may be armed to generate events.  However,
not all sensors support events, you need to use the
@var{ipmi_sensor_threshold_assertion_event_supported}, 
@var{ipmi_sensor_threshold_deassertion_event_supported}, 
@var{ipmi_sensor_discrete_assertion_event_supported}, and
@var{ipmi_sensor_discrete_deassertion_event_supported} calls to tell if
the particular sensor supports events on the given threshold or state.

You can turn event generation on and off for sensors that support it
using the status field of @var{ipmi_event_state_t} by setting or
clearing @var{IPMI_SENSOR_EVENTS_ENABLED} in the bitmask.  You must
first initialize the structure with @var{ipmi_event_state_init}, then
set the specific events you are interested in using the
@var{ipmi_threshold_event_set}, @var{ipmi_threshld_event_clear},
@var{ipmi_discrete_event_set}, and @var{ipmi_discrete_event_clear}, then
call @var{ipmi_sensor_events_enable_set} to set the thresholds.  You can
use @var{ipmi_sensor_events_enable_get} to fetch the current events
setting. You have to use @var{ipmi_sensor_get_sensor_init_events}
function to tell if you need to initialize the events.  The
@var{ipmi_sensor_get_event_support} function returns the support for
events.

You register to receive events for a sensor with
@var{ipmi_sensor_set_event_handler}, which sets a callback that gets
called when an event comes in from the given sensor.  When the callback
comes in, the information from the event is presented, depending on the
sensor type.

For all sensor types, the direction (whether the state causing the event
is being asserted or deasserted) is present.  The offset specifies the
specific state or threshold that caused the event to be asserted.  If
@var{value_present} is true, then the value was passed in the 

@node    Controls, The System Event Log (SEL), Sensors, Using OpenIPMI
@section Controls

As mentioned before, the IPMI standard does not currently define any way
to control output devices.  Of course, this is a huge hole, and is
likely to be filled in the future.  Until then, OpenIPMI defines an
abstraction for handling output devices.  This abstraction is hopefully
good enough for whatever the IPMI committee comes up with in the future,
but there will certainly be changes when it is specified.

Controls are input/output devices.  They currently do not generate any
type of events, they are values which can be set and (optionally) read.
These are relatively simple devices currently, although the IPMI
committee is sure to complicate things in the future.

It is important to note that all operations on a control are serialized,
each control has a queue of operations to perform, and it will only
perform one operation at a time on a control.  This is important, some
operations may require multiple messages to complete, and if you
intermix them it could cause confusion.  It also makes management of the
control easier for the user.

Unfortunately, some hardware does not have individually settable
devices, a set of devices may all be set at once.  This sometimes makes
sense, but usually makes things difficult for the user.  There's not
much OpenIPMI can do about this but pass the difficulty on up to the
user.  Thus, each control may have one or more instances of a device it
controls.  All these devices must be set at once, you cannot
individually set the devices inside one control.

Most controls have individually settable values that are integers.  Some
controls, namely displays and identifiers, have special needs and are
thus represented specially.

@menu
* Simple Controls::
* Lights::
* Fan Speed::
* Identifiers::
* Displays::
@end menu

@node    Simple Controls, Lights, Controls, Controls
@subsection Simple Controls

Simple controls are on/off devices, the values provided are binary
values.  They are different because they control different types of
devices.  These are:

@table @samp
@item Relays - Generally telco relays on a chassis, but any type of relay.
@item Alarms - Visual or audible devices to get a user's attention.
@item Reset - The reset line on a board or device.
@item Power - The power output from a power supply, or power input to a
        device.
@end table

@node    Lights, Fan Speed, Simple Controls, Controls
@subsection Lights

Lights are slightly more complicated than simple devices.  Lights have
colors and blinking settings that must be represented.  Each setting is
represented by a single integer value, and a setting is a series of one or
more transitions the light will go through.  Each transition has a color
and duration.  And, of course, more than one light may be supported in a
single control.

The @var{ipmi_control_get_num_light_settings} function returns the
number of settings a specific light has.  These are defined to be
continuous, if it reports 6, for instance, then the light will have
settings 0-5.

The @var{ipmi_control_get_num_light_transitions} function returns the
number of transitions for a setting.

The @var{ipmi_control_get_light_color} function returns the color a
light will be at a specific setting.

The @var{ipmi_control_get_light_color_time} function returns the time in
milliseconds the transition is valid, before it goes to the next
transition.  This is used to represent blinking modes.  For instance, if
an LED in setting 4 blinks red for 100ms, green for 200ms, then off for
a second, then setting 4 will have 3 transitions, the first will be red
with 100, the second will be green with 200, the last will be black with
1000.

If this seems complicated, well, it is.  Sorry, there's a lot to
represent here.

@node    Fan Speed, Identifiers, Lights, Controls
@subsection Fan Speed

Fan speed allows the user to control the speed of a fan.  FIXME - This
is still TBD, need ways to find the min/max values and number of
settings.

@node    Identifiers, Displays, Fan Speed, Controls
@subsection Identifiers

Identifiers are things on a device that identify characteristics of that
device.  For instance, a unique serial number or a device type would be
identifiers.  These are represented as an array of unsigned characters,
as some identifiers may be very large.  The length may be variable,
too.

The function @var{ipmi_control_identifier_get_val} and
@var{ipmi_control_identifier_set_val} let you read and (optionally)
change the value of an identifier.  If you need to know the maximum
length, the function @var{ipmi_control_identifier_get_max_length}
returns that.  The actual length is returned in the reading when you get
it.

@node    Displays, , Identifiers, Controls
@subsection Displays

FIXME - displays are TBD.

@node    The System Event Log (SEL), , Controls, Using OpenIPMI
@section The System Event Log (SEL)

The SEL on a system receives all the events from a system and stores
them in a non-volatile store.  Depending on the capabilities of the BMC,
these may also have been received via an event message from the system
event queue.  OpenIPMI manages the received events, scans the SEL
periodically, and delivers the messages.  It discards duplicates.
Events that OpenIPMI can correlate to a specific sensor or control will
be delivered to the user through that sensor/control.  Events it cannot
interpret properly will be delivered through a generic interface for the
BMC.

OpenIPMI keeps a local copy of the SEL in memory, but it doesn't
currently use very efficient methods to manage it.  The user should
receive the events and delete them in a timely manner to keep the SEL
small.

The @var{ipmi_register_for_events} function allows you to get the event
OpenIPMI couldn't correlate to a sensor.  As well, the functions
@var{ipmi_bmc_first_log}, @var{ipmi_bmc_last_log},
@var{ipmi_bmc_next_log}, and @var{ipmi_bmc_prev_log} let you iterate
through the logs in the local representation of the SEL.

@node    OpenIPMI Internal Interfaces, How to Write OEM Plugins, Using OpenIPMI, Top
@chapter OpenIPMI Internal Interfaces

@node    How to Write OEM Plugins, Internals, OpenIPMI Internal Interfaces, Top
@chapter How to Write OEM Plugins

@node    Internals, Concept Index, How to Write OEM Plugins, Top
@chapter Internals

This section describes the internals of OpenIPMI.  These details are
subject to change, so don't depend on them for writing portable
software.

@menu
* How Locking Works::
@end menu

@node    How Locking Works, , Internals, Internals
@section How Locking Works

The locking in OpenIPMI is currently rather course-grained, for
simplicity.  In the future, it will probably be more fine-grained.

The system has one read/write lock that protects access to the list of
BMCs.  Every operation locks this lock read (except for the ones that
modify it, which lock it write).  This prevents a BMC from going away
while it's in use.

Every BMC has an @var{mc_list_lock}, that lock is used to lock anything
on the BMC or any MC's in the BMC.  As well, there is an
@var{entities_lock} in the BMC, it is locked for any entities in the
BMC.

SDRs, since they may stand alone after their underpinnings have been
destroyed, have their own lock.

The various interfaces have their own locks, too, for handling sequence
numbering and the like.  These are interface-dependent and should not
concern the user since they shouldn't be held during user calls.

@node    Concept Index, Glossary,  Internals, Top
@unnumbered Concept Index

@printindex cp

@node    Glossary,       , Concept Index, Top
BMC
callback
discrete sensor
entity
FRU
OpenIPMI id
IPMB
IPMI
LUN
MC
presence sensor
SDR
SEL
slave address
threshold
threshold sensor
@contents
@bye
