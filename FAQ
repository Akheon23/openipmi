
  1) Why is ipmi_ui so ugly?

     Well, ipmi_ui is a test program that I wrote for my own purposes.
     I'll try to clean it up in the future and make it into something
     useful, and it's certainly ugly, but it's primarily for my
     testing.

     If you want to write something useful to replace it, feel free!


  2) What if I just want to send some IPMI commands.

     Then "ipmicmd" is the tools for you.  It can connect to a system
     interface or to a LAN connection and let you directly enter
     commands.


  3) I'm trying to write a little program that comes up and queries a
     few things.  Can I use the OpenIPMI library to do that?

     Probably not.  OpenIPMI was designed as a large-scale IPMI
     interface for programs that stay up and do lots of management
     work.  It's not really for one-off little tools.

     If you want to do small tools, it's easy enough to just open the
     device and send the commands (or use the ipmicmd tool).  You have
     to understand IPMI well to use it at that level, anyway.


  4) Why can't I just perform an operation and immediately get the
     results?  Why all these callbacks?

     Read the documenation for details.  The OpenHPI interface
     (http://openhpi.sourceforce.net) is expected to sit on top of the
     OpenIPMI library and provide an interface more like that.  Plus,
     you can write your own wrappers to do it.  It's not possible to
     write event-driven wrappers on top of a non-event-driven
     interface.


  5) Can I have multiple OpenIPMI session from different programs to
     the same interface?

     Certainly.  I do it all the time :-)

     The main problem is the System Event Log (SEL).  Somebody has to
     delete items from the SEL.  You have a couple of options...

     If you don't care about the SEL, then set the SEL rescan time to
     zero with ipmi_domain_set_sel_rescan_time().  This will turn off
     the SEL completely.

     If you do care about SELs on multiple programs, you will have to
     develop a protocol between all the users.  You have to have a way
     to let all the listeners get all the SELs, but still delete items
     from the SEL in a timely manner.  I recommend that you set the
     SEL rescan time to a value, and for every event receive wait
     double that value before deleting it.  OpenIPMI will correctly
     handle multiple things deleting items from the SEL.


  6) Can you open more than one IPMI session from OpenIPMI?

     Certainly.  You can create as many connections and domains as you
     like, the library has no limitiation.


  7) I have an xyz computer, does OpenIPMI support it?

     That depends on a lot of things.  Does the box have IPMI?  Most
     systems do not, it's currently mostly on high-end system.  If the
     system does have IPMI, OpenIPMI will probably support it.  It may
     not support the full function of your system though.  Output
     devices are not defined by the IPMI spec, so they are all OEM and
     require custom code to control them.  Sensors that do not appear
     in an SDR repository will not be supported without custom code.
     Any things custom to the system will probably not be supported.


  8) What interfaces does OpenIPMI support?

     OpenIPMI currently supports system interfaces through the
     OpenIPMI device driver and LAN interfaces.  It does not support
     serial interfaces or any type of callback devices.


  9) Does OpenIPMI support ICMB?

     Not currently, although it shouldn't be hard to add.


 10) How do I learn more about IPMI?

     Not much information currently exists.  The OpenIPMI web site has
     a pointer to the specs and the documentation that comes with
     IPMI, but the spec is very hard to read and the documentation is
     really more marketing level.  The documentation that comes with
     OpenIPMI provides a more gentle introduction to IPMI (you should
     certainly read it before you read the spec) but it's more focused
     on OpenIPMI, not IPMI proper.

     Someone needs to write a book (and it's not going to be me).


 11) What does OpenIPMI do?

     OpenIPMI attempts to handle a lot of the difficult parts of IPMI
     for the user; as much as it can without making too many policy
     decisions for the user.  For instance, it:
     * Fetches all the SDRs and translates them into sensors and
       entity information.
     * Manages access to the SEL.
     * Handles the interface, which is especially hard for LAN
       connections.
     * Handles fetching FRU information for entities.
     * Lets you deal directly with sensors and entities.
     * Periodically scans all the information it manages to see if
       it has changed.
     * Decodes incoming events, correlates them with sensors,
       translates raw values into useful values, and delivers them
       with the sensor object.
     * Allows OEM code to plug in to fix up things and present
       non-standard devices through standard interfaces.
     Basically, the user just has to start up the connection and wait
     for things to happen.  As OpenIPMI finds things, it will report
     them and the user can take action.  It is designed to remove the
     low-level details from the user's concern and only present the
     things the user is really interested in handling.


 12) I don't like the way OpenIPMI does x.

     You may disagree with implementation decisions I have made and
     that's fine.  You can make suggestions, submit patches, and work
     with me on this.  Or you may write your own IPMI library.  Or you
     may pillage OpenIPMI to get what you want.  Like Linus holds
     final say on what goes into his distribution of Linux, I hold
     final say on what goes into my distribution of OpenIPMI.  But
     that doesn't mean you can't do your own work on it.


 13) Why did you write OpenIPMI?

     OpenIPMI was originally written to support a customer who needed
     an interface for their IPMI platform.  It was also designed with
     HPI in mind, for something to implement as the base to an HPI
     library.


 14) I just want to use pieces of OpenIPMI, can I?

     Well, it's open source.  But unfortunately, OpenIPMI is not
     terribly modular as a whole.  Certain parts (the interface code,
     for instance) can be used stand-alone.  But SDRs, MC, SELs,
     domains, sensors, etc. all know about each other.  It's somewhat
     inescapable, really, the concepts are intertwined.  It would be
     fairly easy to take any individual piece of the code (the sdr.c
     code, for instance) and change it to work in a different system,
     but you would have to change the code to do that.


 15) Why is the OpenIPMI interface the way it is (bad, good, ugly,
     elegent, simple, obtuse, etc)?

     My basic philosophy of API design is:

     1) Users should only have to deal with the objects they really
        care about.  You should distill the interface down to what the
        user really cares about.  Think about it from the user's point
        of view and implement what they want.

     2) Users (especially me) have a hard time dealing with large
        numbers of types.  Distill the types down to the essentials.
        Don't overload types with information that doesn't belong in
        them, either.  Essentials are essentials; don't go beyond
        them, though.

     3) Interfaces should be designed with extensibility in mind.  All
        types should be opaque pointers so that the internal
        representation and implementation can change without the
        binary or logical interface changing.  If you make an
        exception on this, it better be for a really good reason.

     4) Use the basic types of the language as much as possible.  It's
        better to have more functions than types.

     I'm very picky about this.  I have seen too many bad APIs; ones
     based on the implementation, not the needs of the user.


 16) My IPMI system has some broken information in it.  Can I fix it?

     Sure.  You can write OEM code that ties in to when objects are
     added to the system and fix them up as necessary.